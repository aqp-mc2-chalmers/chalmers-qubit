{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"chalmers-qubit","text":"<p>A simulation framework for Chalmers devices that can be used to simulate the running of quantum algorithms with realistic noise. We follow qutip-qip to build a processor that can take in a quantum circuit (e.g., a QASM cicruit) and performs a master equation simulation adding noise such as T1 and T2. It is also possible to perform a Monte-Carlo trajectory simulation and customize the processor to add various types of noise such as ZZCrossTalk.</p> <p>The package is under development and testing.</p>"},{"location":"#installation","title":"Installation","text":"<p>The main requirement to use this package is qutip-qip based on qutip: The Quantum Toolbox in Python. The requirements are already specified in the <code>setup.cfg</code> file and you can install the package <code>chalmers_qubit</code> simply by downloading this folder or cloning this repository and running:</p> <pre><code>pip install .\n</code></pre> <p>to get the minimal installation. However, it might be beneficial to install an editable version. In the editable version, changes to the code are reflected system-wide without requiring a reinstallation.</p> <pre><code>pip install -e .\n</code></pre> <p>If you do not care about making changes to the source code and just want to try out the package (e.g., from Google Colab), you can do a git+ install with</p> <pre><code>pip install git+https://github.com/aqp-mc2-chalmers/chalmers-qubit.git\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The usage of the package follows qutip-qip where first, a quantum circuit is defined using <code>qutip-qip</code> and then run on one of the custom Chalmers processors, e.g., the processor called sarimner. The custom processor is defined in <code>chalmers_qubit.devices.sarimner.processor</code> and can be initialized with a <code>model</code>, <code>compiler</code> and <code>noise</code>.</p> <p>Note that only gates with compilation instructions in <code>chalmers_qubit/sarimner/compiler.py</code> will work for this particular processor.</p> <p>Notebooks exploring the usage of the simulator is available in <code>docs/examples/</code>.</p> <pre><code>import numpy as np\nfrom qutip import basis, tensor\nfrom qutip_qip.circuit import QubitCircuit\nfrom chalmers_qubit.devices.sarimner import (\n    SarimnerProcessor,\n    SarimnerModel,\n    SarimnerCompiler,\n    DecoherenceNoise,\n    ZZCrossTalk,\n)\n\n# Define a quantum circuit\nqc = QubitCircuit(2)\nqc.add_gate(\"RX\", targets=0, arg_value=np.pi / 2)\nqc.add_gate(\"RY\", targets=1, arg_value=np.pi / 2)\nqc.add_gate(\"CZ\", controls=0, targets=1)\n\n# All frequencies are defined in GHz, and times in ns.\ntransmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n    1: {\"frequency\": 5.4, \"anharmonicity\": -0.30},\n}\ncoupling_dict = {\n    (0, 1): 0.04,\n}\n# Construct model\nmodel = SarimnerModel(transmon_dict=transmon_dict,\n                      coupling_dict=coupling_dict)\n\n# Load a compiler\ncompiler = SarimnerCompiler(model=model)\n\n# Define all the noise objects as a list.\ndecoherence_dict = {\n    0: {\"t1\": 60e3, \"t2\": 80e3},\n    1: {\"t1\": 100e3, \"t2\": 105e3},\n}\ncross_talk_dict = {\n    (0, 1): 1e-4,\n}\nnoise = [\n    DecoherenceNoise(decoherence_dict=decoherence_dict),\n    ZZCrossTalk(cross_talk_dict=cross_talk_dict),\n]\n\n# Initialize the processor\nprocessor = SarimnerProcessor(model=model, compiler=compiler, noise=noise)\n\n# Load the circuit that generates the pulses to run the simulation\ntlist, coeffs = processor.load_circuit(qc)\n\n# Initial state for the simulation.\n# The default assumptions is that each transmon is a qudit with 3 levels.\ninit_state = tensor(basis(3, 1), basis(3, 1))\n\n# Run master equation simulation\nresult = processor.run_state(init_state)\nprint(\"Final state\", result.states[-1])\n\n# Run the same circuit but with mcsolve using 100 trajectories.\nresult = processor.run_state(init_state, solver=\"mcsolve\", ntraj=100)\nprint(\"Final state\", result.states[-1])\n</code></pre> <p>It is also possible to import QASM circuits.</p>"},{"location":"#development","title":"Development","text":"<p>In order to add new custom pulses or modify the device, edit the processor, or compiler the tutorials and detailed instructions in qutip-qip.</p> <p>The tutorials show examples of how to customize the processor. If you have installed the package in the develop mode, any changes to the processor, e.g., adding a new gate will be reflected immediately system-wide without requiring a reinstallation of the package.</p>"},{"location":"#support","title":"Support","text":"<p>This package was built from contributions by Pontus Vikst\u00e5l and Shahnawaz Ahmed.</p> <p>Contact vikstal@chalmers.se, shahnawaz.ahmed95@gmail.com or anton.frisk.kockum@chalmers.se for help and support.</p>"},{"location":"examples/comparison_of_coherence_limits/","title":"Comparison of coherence limits of GHZ state via compilation to two- or three-qubit gates.","text":"<p>Import Packages</p> In\u00a0[1]: Copied! <pre>import numpy as np\nfrom qutip import tensor, basis, ket2dm, fidelity\nfrom qutip_qip.circuit import QubitCircuit\nfrom qutip_qip.operations.gates import rz\nfrom chalmers_qubit.devices.sarimner import (\n    SarimnerProcessor,\n    SarimnerModel,\n    SarimnerCompiler,\n    DecoherenceNoise,\n)\nfrom chalmers_qubit.utils.operations import project_on_qubit\n\nimport warnings\nwarnings.simplefilter(action=\"ignore\", category=FutureWarning)\n</pre> import numpy as np from qutip import tensor, basis, ket2dm, fidelity from qutip_qip.circuit import QubitCircuit from qutip_qip.operations.gates import rz from chalmers_qubit.devices.sarimner import (     SarimnerProcessor,     SarimnerModel,     SarimnerCompiler,     DecoherenceNoise, ) from chalmers_qubit.utils.operations import project_on_qubit  import warnings warnings.simplefilter(action=\"ignore\", category=FutureWarning) <p>Create GHZ-circuit for 3 qubits: One circuit is uing th three-qubit gate, the other one is using a two-qubit gate.</p> In\u00a0[2]: Copied! <pre>from chalmers_qubit.utils.gates import cczs\n\ndef ghz_two_qubit_gate():\n    # Circuit to create GHZ-state using 2-qubit gate\n    circuit = QubitCircuit(3)\n    circuit.add_gate(\"H\", targets=0)\n    for i in range(1, 3):\n        circuit.add_gate(\"H\", targets=i)\n        circuit.add_gate(\"CZ\", controls=0, targets=i)\n        circuit.add_gate(\"H\", targets=i)\n    return circuit\n\ndef ghz_three_qubit_gate():\n    # Circuit to create GHZ-state using 3-qubit gate\n    circuit = QubitCircuit(3)\n    circuit.user_gates = {\"CCZS\": cczs}\n    circuit.add_gate(\"H\", targets=0)\n    for i in range(1, 2):\n        circuit.add_gate(\"X\", targets=i)\n        circuit.add_gate(\"CCZS\", targets=[0, i, i + 1], arg_value=[np.pi / 2, 0, 0])\n        circuit.add_gate(\"X\", targets=i)\n    return circuit\n</pre> from chalmers_qubit.utils.gates import cczs  def ghz_two_qubit_gate():     # Circuit to create GHZ-state using 2-qubit gate     circuit = QubitCircuit(3)     circuit.add_gate(\"H\", targets=0)     for i in range(1, 3):         circuit.add_gate(\"H\", targets=i)         circuit.add_gate(\"CZ\", controls=0, targets=i)         circuit.add_gate(\"H\", targets=i)     return circuit  def ghz_three_qubit_gate():     # Circuit to create GHZ-state using 3-qubit gate     circuit = QubitCircuit(3)     circuit.user_gates = {\"CCZS\": cczs}     circuit.add_gate(\"H\", targets=0)     for i in range(1, 2):         circuit.add_gate(\"X\", targets=i)         circuit.add_gate(\"CCZS\", targets=[0, i, i + 1], arg_value=[np.pi / 2, 0, 0])         circuit.add_gate(\"X\", targets=i)     return circuit <p>We can plot the circuits</p> In\u00a0[3]: Copied! <pre>ghz_two_qubit_gate()\n</pre> ghz_two_qubit_gate() Out[3]: <pre></pre> In\u00a0[4]: Copied! <pre>ghz_three_qubit_gate()\n</pre> ghz_three_qubit_gate() Out[4]: <pre></pre> <p>Define three-qubit device parameters</p> In\u00a0[5]: Copied! <pre>transmon_dict = {\n    0: {\"frequency\": 5.02, \"anharmonicity\": -0.3},\n    1: {\"frequency\": 5.47, \"anharmonicity\": -0.28},\n    2: {\"frequency\": 5.25, \"anharmonicity\": -0.34},\n}\ndecoherence_dict = {\n    0: {\"t1\": 60e3, \"t2\": 100e3},\n    1: {\"t1\": 80e3, \"t2\": 105e3},\n    2: {\"t1\": 70e3, \"t2\": 103e3},\n}\n# Compiler options\noptions = {\n    \"dt\": 0.01, # time step in (ns)\n    \"two_qubit_gate\": {\n        \"buffer_time\": 0,\n        \"rise_fall_time\": 0,\n    },\n}\n</pre> transmon_dict = {     0: {\"frequency\": 5.02, \"anharmonicity\": -0.3},     1: {\"frequency\": 5.47, \"anharmonicity\": -0.28},     2: {\"frequency\": 5.25, \"anharmonicity\": -0.34}, } decoherence_dict = {     0: {\"t1\": 60e3, \"t2\": 100e3},     1: {\"t1\": 80e3, \"t2\": 105e3},     2: {\"t1\": 70e3, \"t2\": 103e3}, } # Compiler options options = {     \"dt\": 0.01, # time step in (ns)     \"two_qubit_gate\": {         \"buffer_time\": 0,         \"rise_fall_time\": 0,     }, } <p>Write a script to loop over different cz-gate times</p> In\u00a0[6]: Copied! <pre>def run_sarimner_simulation(circuit, transmon_dict, decoherence_dict, options_dict=None):\n    # Simulation parameters\n    tlist = np.linspace(20, 200, 10)  # Times in (ns)\n    fidelities = []\n\n    for t in tlist:\n        # Calculate the corresponding coupling strength\n        g = 1 / (np.sqrt(2) * 2 * t)\n        coupling_dict = {(0, 1): g, (0, 2): -g}\n\n        # Set up the model, compiler, and processor\n        model = SarimnerModel(transmon_dict=transmon_dict, coupling_dict=coupling_dict)\n        compiler = SarimnerCompiler(model=model, options=options)\n        noise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]\n        sarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise)\n\n        # Load circuit\n        sarimner.load_circuit(circuit)\n\n        # Simulate circuit\n        init_state = tensor([basis(3, 0)] * 3)\n        res = sarimner.run_state(\n            init_state=init_state, options={\"nsteps\": 1e6, \"atol\": 1e-12}\n        )\n\n        # Post-process results\n        final_state = project_on_qubit(res.states[-1])\n        qubit_state = rz(np.pi, N=3) * final_state * rz(np.pi, N=3).dag()\n\n        # Calculate fidelity\n        ideal_state = circuit.compute_unitary() * tensor([basis(2, 0)] * 3)\n        fidelities.append(fidelity(qubit_state, ideal_state))\n\n    return tlist, fidelities\n</pre> def run_sarimner_simulation(circuit, transmon_dict, decoherence_dict, options_dict=None):     # Simulation parameters     tlist = np.linspace(20, 200, 10)  # Times in (ns)     fidelities = []      for t in tlist:         # Calculate the corresponding coupling strength         g = 1 / (np.sqrt(2) * 2 * t)         coupling_dict = {(0, 1): g, (0, 2): -g}          # Set up the model, compiler, and processor         model = SarimnerModel(transmon_dict=transmon_dict, coupling_dict=coupling_dict)         compiler = SarimnerCompiler(model=model, options=options)         noise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]         sarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise)          # Load circuit         sarimner.load_circuit(circuit)          # Simulate circuit         init_state = tensor([basis(3, 0)] * 3)         res = sarimner.run_state(             init_state=init_state, options={\"nsteps\": 1e6, \"atol\": 1e-12}         )          # Post-process results         final_state = project_on_qubit(res.states[-1])         qubit_state = rz(np.pi, N=3) * final_state * rz(np.pi, N=3).dag()          # Calculate fidelity         ideal_state = circuit.compute_unitary() * tensor([basis(2, 0)] * 3)         fidelities.append(fidelity(qubit_state, ideal_state))      return tlist, fidelities In\u00a0[7]: Copied! <pre>tlist, fidelities_2 = run_sarimner_simulation(ghz_two_qubit_gate(), transmon_dict, decoherence_dict, options)\n</pre> tlist, fidelities_2 = run_sarimner_simulation(ghz_two_qubit_gate(), transmon_dict, decoherence_dict, options) In\u00a0[8]: Copied! <pre>tlist, fidelities_3 = run_sarimner_simulation(ghz_three_qubit_gate(), transmon_dict, decoherence_dict, options)\n</pre> tlist, fidelities_3 = run_sarimner_simulation(ghz_three_qubit_gate(), transmon_dict, decoherence_dict, options) In\u00a0[9]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.plot(tlist, (1 - np.array(fidelities_2)) * 100, \"-x\", label=\"cz\")\nplt.plot(tlist, (1 - np.array(fidelities_3)) * 100, \"-x\", label=\"cczs\")\nplt.legend()\nplt.ylabel(\"Infidelity %\")\nplt.xlabel(\"CZ-gate time (ns)\")\nplt.title(\"GHZ state\")\n</pre> import matplotlib.pyplot as plt  plt.plot(tlist, (1 - np.array(fidelities_2)) * 100, \"-x\", label=\"cz\") plt.plot(tlist, (1 - np.array(fidelities_3)) * 100, \"-x\", label=\"cczs\") plt.legend() plt.ylabel(\"Infidelity %\") plt.xlabel(\"CZ-gate time (ns)\") plt.title(\"GHZ state\") Out[9]: <pre>Text(0.5, 1.0, 'GHZ state')</pre> <p>If we compare this plot to Figure 5a. from the paper we see the same trend</p> <p></p>"},{"location":"examples/comparison_of_coherence_limits/#comparison-of-coherence-limits-of-ghz-state-via-compilation-to-two-or-three-qubit-gates","title":"Comparison of coherence limits of GHZ state via compilation to two- or three-qubit gates.\u00b6","text":"<p>In this tutorial we are going to recreate the results from the paper https://www.nature.com/articles/s41534-023-00711-x</p>"},{"location":"examples/quantum_gates/","title":"Quantum Gates","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom qutip import tensor, basis, ket2dm, average_gate_fidelity, Qobj\nfrom qutip_qip.circuit import QubitCircuit\nfrom chalmers_qubit.devices.sarimner import *\nfrom chalmers_qubit.utils.operations import project_on_qubit\n\nimport warnings\nwarnings.simplefilter(action=\"ignore\", category=FutureWarning)\n\n%load_ext autoreload\n%autoreload 2\n</pre> import numpy as np from qutip import tensor, basis, ket2dm, average_gate_fidelity, Qobj from qutip_qip.circuit import QubitCircuit from chalmers_qubit.devices.sarimner import * from chalmers_qubit.utils.operations import project_on_qubit  import warnings warnings.simplefilter(action=\"ignore\", category=FutureWarning)  %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>num_qubits = 1\ncircuit = QubitCircuit(num_qubits)\ncircuit.add_gate(\"RX\", targets=0, arg_value=np.pi)\n</pre> num_qubits = 1 circuit = QubitCircuit(num_qubits) circuit.add_gate(\"RX\", targets=0, arg_value=np.pi) <p>Next we define the hardware parameters that we will use when simulating this quantum circtuit. We therefore define a dictionary where the <code>key</code> corresponds to the qubit index and the value is another <code>dict</code> that can have the following values:</p> <ul> <li><code>frequency</code>: Qubit frequency in GHz.</li> <li><code>anharmonicity</code>: Qubit anharmonicity in GHz.</li> </ul> <p>We will also create another dict with the decoherence values for the qubit, the <code>key</code> needs to match the qubit index, and the value is another <code>dict</code> with the relaxation times</p> <ul> <li><code>t1</code>: $T_1$ of the qubit in nano seconds.</li> <li><code>t2</code>: $T_2$ of the qubit in nano seconds.</li> </ul> In\u00a0[3]: Copied! <pre>transmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n}\ndecoherence_dict = {\n    0: {\"t1\": 60e3, \"t2\": 100e3},\n}\n</pre> transmon_dict = {     0: {\"frequency\": 5.0, \"anharmonicity\": -0.30}, } decoherence_dict = {     0: {\"t1\": 60e3, \"t2\": 100e3}, } <p>Next we take these hardware parameters that we have defined and we load them into our superconducting hardware model <code>SarimnerModel</code>. The <code>SarimnerModel</code> along with the <code>SarimnerCompiler</code> and <code>noise</code> are given to <code>SarimnerProcessor</code> as shown in the figure below.</p> In\u00a0[4]: Copied! <pre># Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n\n# Choose compiler\ncompiler = SarimnerCompiler(model=model)\n\n# Add noise\nnoise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise)\n</pre> # Load the physical parameters onto the model model = SarimnerModel(transmon_dict=transmon_dict)  # Choose compiler compiler = SarimnerCompiler(model=model)  # Add noise noise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]  # Create the processor with the given hardware parameters sarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise) <p>Once we have defined our processor we can load the quantum circuit onto the processor. This will compile the circuit into a pulse sequence.</p> In\u00a0[5]: Copied! <pre>tlist, coeffs = sarimner.load_circuit(circuit)\n</pre> tlist, coeffs = sarimner.load_circuit(circuit) <p>We can choose to plot the pulse sequence</p> In\u00a0[6]: Copied! <pre>fig, ax = sarimner.plot_pulses(show_axis=True, figsize=(6,3));\n</pre> fig, ax = sarimner.plot_pulses(show_axis=True, figsize=(6,3)); <p>Now we can exectue this pulse sequence on the processor by using <code>run_state</code> with a given <code>initial state</code></p> In\u00a0[7]: Copied! <pre>initial_state = basis(3,0)\nresult = sarimner.run_state(initial_state)\nfinal_state = result.states[-1]\nfinal_state\n</pre> initial_state = basis(3,0) result = sarimner.run_state(initial_state) final_state = result.states[-1] final_state Out[7]:  Quantum object: dims=[[3], [3]], shape=(3, 3), type='oper', dtype=Dense, isherm=True$$\\left(\\begin{array}{cc}3.966\\times10^{ -4 } &amp; 0.002j &amp; 2.968\\times10^{ -8 }\\\\-0.002j &amp; 1.000 &amp; 3.140\\times10^{ -7 }\\\\2.968\\times10^{ -8 } &amp; 3.140\\times10^{ -7 } &amp; 1.327\\times10^{ -7 }\\end{array}\\right)$$  <p>Since we simulated the system for a three-level system we have to project it onto the computational subspace using the function <code>project_on_qubit</code></p> In\u00a0[8]: Copied! <pre>project_on_qubit(final_state)\n</pre> project_on_qubit(final_state) Out[8]:  Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True$$\\left(\\begin{array}{cc}3.966\\times10^{ -4 } &amp; 0.002j\\\\-0.002j &amp; 1.000\\end{array}\\right)$$  <p>Next we show a simple circuit using a two-qubit <code>CZ</code>-gate and how to compile it onto our processor.</p> In\u00a0[9]: Copied! <pre># Define a circuit and run the simulation\nnum_qubits = 2\ncircuit = QubitCircuit(num_qubits)\ncircuit.add_gate(\"CZ\", controls=0, targets=1)\n</pre> # Define a circuit and run the simulation num_qubits = 2 circuit = QubitCircuit(num_qubits) circuit.add_gate(\"CZ\", controls=0, targets=1) <p>Just as before we start by defining our hardware parameters.</p> In\u00a0[10]: Copied! <pre>transmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n    1: {\"frequency\": 5.4, \"anharmonicity\": -0.30},\n}\ndecoherence_dict = {\n    0: {\"t1\": 60e3, \"t2\": 80e3},\n    1: {\"t1\": 100e3, \"t2\": 105e3},\n}\n</pre> transmon_dict = {     0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},     1: {\"frequency\": 5.4, \"anharmonicity\": -0.30}, } decoherence_dict = {     0: {\"t1\": 60e3, \"t2\": 80e3},     1: {\"t1\": 100e3, \"t2\": 105e3}, } <p>Additionally we need to supply information of how the qubits are coupled together. This is done using another dictionary, where the value is supplied as a tuple <code>(i,j)</code> defining qubit $i$ and qubit $j$ and the value is the coupling strength in GHz.</p> In\u00a0[11]: Copied! <pre># The time for the CZ-gate that we want in (ns)\nt = 100\n\n# Corresponding coupling in (GHz)\ng = 1 / (np.sqrt(2) * 2 * t)\n\ncoupling_dict = {\n    (0, 1): g,\n}\n</pre> # The time for the CZ-gate that we want in (ns) t = 100  # Corresponding coupling in (GHz) g = 1 / (np.sqrt(2) * 2 * t)  coupling_dict = {     (0, 1): g, } <p>and load them onto our model</p> In\u00a0[12]: Copied! <pre># Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict, coupling_dict=coupling_dict)\n# Options for compiler\noptions = {\n    \"dt\": 0.1, # time-step of simulator in (ns)\n    \"two_qubit_gate\": {\n        \"buffer_time\": 10, # buffer-time of two-qubit gate in (ns)\n        \"rise_fall_time\": 0, # sinusodial rise and fall time of two-qubit gate in (ns)\n    },\n}\n# Choose compiler\ncompiler = SarimnerCompiler(model=model, options=options)\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, compiler=compiler)\n</pre> # Load the physical parameters onto the model model = SarimnerModel(transmon_dict=transmon_dict, coupling_dict=coupling_dict) # Options for compiler options = {     \"dt\": 0.1, # time-step of simulator in (ns)     \"two_qubit_gate\": {         \"buffer_time\": 10, # buffer-time of two-qubit gate in (ns)         \"rise_fall_time\": 0, # sinusodial rise and fall time of two-qubit gate in (ns)     }, } # Choose compiler compiler = SarimnerCompiler(model=model, options=options) # Create the processor with the given hardware parameters sarimner = SarimnerProcessor(model=model, compiler=compiler) <p>Then we can compile the circuit onto our processor</p> In\u00a0[13]: Copied! <pre>tlist, coeffs = sarimner.load_circuit(circuit)\n</pre> tlist, coeffs = sarimner.load_circuit(circuit) In\u00a0[14]: Copied! <pre>cz_real, cz_imag = coeffs[\"cz_real01\"], coeffs[\"cz_imag01\"]\ncz = np.sqrt(cz_real**2 + cz_imag**2)\ntlist_real, tlist_imag = tlist[\"cz_real01\"], tlist[\"cz_imag01\"]\n</pre> cz_real, cz_imag = coeffs[\"cz_real01\"], coeffs[\"cz_imag01\"] cz = np.sqrt(cz_real**2 + cz_imag**2) tlist_real, tlist_imag = tlist[\"cz_real01\"], tlist[\"cz_imag01\"] In\u00a0[15]: Copied! <pre>np.trapezoid(cz, tlist_real)\n</pre> np.trapezoid(cz, tlist_real) Out[15]: <pre>np.float64(100.0)</pre> In\u00a0[16]: Copied! <pre>area = np.trapezoid(y=cz_real, x=tlist_real) + np.trapezoid(y=cz_real, x=tlist_real)\n</pre> area = np.trapezoid(y=cz_real, x=tlist_real) + np.trapezoid(y=cz_real, x=tlist_real) In\u00a0[17]: Copied! <pre>sarimner.plot_pulses(show_axis=True, figsize=(6,3));\n</pre> sarimner.plot_pulses(show_axis=True, figsize=(6,3)); <p>To see that the CZ-gate is implemented correctly we will now simulate the circuit using the master equation simulation and look at the expectation values of the $|11\\rangle$ and $|20\\rangle$ states.</p> In\u00a0[18]: Copied! <pre>ket01 = tensor(basis(3,0), basis(3,1))\nket10 = tensor(basis(3,1), basis(3,0))\nket11 = tensor(basis(3,1), basis(3,1))\nket20 = tensor(basis(3,2), basis(3,0))\n# List of operators we wanna compute the expectation value for during the simulation\ne_ops = [ket2dm(ket01), ket2dm(ket10), ket2dm(ket11), ket2dm(ket20)]\nresult = sarimner.run_state(ket11, e_ops=e_ops, options={'nsteps': 1e5, 'store_final_state': True})\n</pre> ket01 = tensor(basis(3,0), basis(3,1)) ket10 = tensor(basis(3,1), basis(3,0)) ket11 = tensor(basis(3,1), basis(3,1)) ket20 = tensor(basis(3,2), basis(3,0)) # List of operators we wanna compute the expectation value for during the simulation e_ops = [ket2dm(ket01), ket2dm(ket10), ket2dm(ket11), ket2dm(ket20)] result = sarimner.run_state(ket11, e_ops=e_ops, options={'nsteps': 1e5, 'store_final_state': True}) In\u00a0[19]: Copied! <pre>import matplotlib.pyplot as plt\nplt.plot(result.times, result.expect[0], label=\"01\")\nplt.plot(result.times, result.expect[1], label=\"10\")\nplt.plot(result.times, result.expect[2], label='11')\nplt.plot(result.times, result.expect[3], label='20')\nplt.xlabel('Time (ns)')\nplt.ylabel('Population')\nplt.legend()\n</pre> import matplotlib.pyplot as plt plt.plot(result.times, result.expect[0], label=\"01\") plt.plot(result.times, result.expect[1], label=\"10\") plt.plot(result.times, result.expect[2], label='11') plt.plot(result.times, result.expect[3], label='20') plt.xlabel('Time (ns)') plt.ylabel('Population') plt.legend() Out[19]: <pre>&lt;matplotlib.legend.Legend at 0x163760400&gt;</pre> <p>And if we print the final state we see that the $|11\\rangle$ state has the desired $-1$ phase.</p> In\u00a0[20]: Copied! <pre>qubit_state = project_on_qubit(result.final_state)\nqubit_state\n</pre> qubit_state = project_on_qubit(result.final_state) qubit_state Out[20]:  Quantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense$$\\left(\\begin{array}{cc}0\\\\0\\\\0\\\\-1.000\\end{array}\\right)$$  <p>Finally we will demonstrate the implementation of the three-qubit gate.</p> <p>Since this gate is not part of qutip <code>QubitCircuit</code> we have to defined the gate ourself and supply as <code>user_gates</code></p> In\u00a0[21]: Copied! <pre>from qutip import Qobj\n# Ideal gate\ndef cczs(args):\n    theta, phi, gamma = args\n    U = np.array([[1, 0, 0, 0, 0, 0, 0, 0],\n                  [0, 1, 0, 0, 0, 0, 0, 0],\n                  [0, 0, 1, 0, 0, 0, 0, 0],\n                  [0, 0, 0, 1, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 1, 0, 0, 0],\n                  [0, 0, 0, 0, 0, -np.exp(-1j*gamma)*np.sin(theta/2)**2 + np.cos(theta/2)**2, \n                                    (1/2)*(1 + np.exp(-1j*gamma))*np.exp(-1j*phi)*np.sin(theta), 0],\n                  [0, 0, 0, 0, 0, (1/2)*(1 + np.exp(-1j*gamma))*np.exp(1j*phi)*np.sin(theta), \n                                    -np.exp(-1j*gamma)*np.cos(theta/2)**2 + np.sin(theta/2)**2, 0],\n                  [0, 0, 0, 0, 0, 0, 0, -np.exp(1j*gamma)]], dtype=\"complex\")\n    return Qobj(U, dims=[[2]*3, [2]*3])\n</pre> from qutip import Qobj # Ideal gate def cczs(args):     theta, phi, gamma = args     U = np.array([[1, 0, 0, 0, 0, 0, 0, 0],                   [0, 1, 0, 0, 0, 0, 0, 0],                   [0, 0, 1, 0, 0, 0, 0, 0],                   [0, 0, 0, 1, 0, 0, 0, 0],                   [0, 0, 0, 0, 1, 0, 0, 0],                   [0, 0, 0, 0, 0, -np.exp(-1j*gamma)*np.sin(theta/2)**2 + np.cos(theta/2)**2,                                      (1/2)*(1 + np.exp(-1j*gamma))*np.exp(-1j*phi)*np.sin(theta), 0],                   [0, 0, 0, 0, 0, (1/2)*(1 + np.exp(-1j*gamma))*np.exp(1j*phi)*np.sin(theta),                                      -np.exp(-1j*gamma)*np.cos(theta/2)**2 + np.sin(theta/2)**2, 0],                   [0, 0, 0, 0, 0, 0, 0, -np.exp(1j*gamma)]], dtype=\"complex\")     return Qobj(U, dims=[[2]*3, [2]*3]) <p>Alternatively we can just import the gate from <code>chalmers_qubit.utils.gates</code></p> In\u00a0[22]: Copied! <pre>from chalmers_qubit.utils.gates import cczs\n</pre> from chalmers_qubit.utils.gates import cczs In\u00a0[23]: Copied! <pre># Define a circuit and run the simulation\nnum_qubits = 3\n\ncircuit = QubitCircuit(num_qubits)\ncircuit.user_gates = {\"CCZS\": cczs}\ncircuit.add_gate(\"CCZS\", targets=[0,1,2], arg_value=[np.pi/2,0,0])\n</pre> # Define a circuit and run the simulation num_qubits = 3  circuit = QubitCircuit(num_qubits) circuit.user_gates = {\"CCZS\": cczs} circuit.add_gate(\"CCZS\", targets=[0,1,2], arg_value=[np.pi/2,0,0]) In\u00a0[24]: Copied! <pre>transmon_dict = {\n            0: {\"frequency\": 5.0, \"anharmonicity\": 0.3},\n            1: {\"frequency\": 5.4, \"anharmonicity\": 0.3},\n            2: {\"frequency\": 5.2, \"anharmonicity\": 0.3},\n        }\n\n# Times in (ns)\nt = 100\n\n# corresponding coupling\ng = 1 / (np.sqrt(2) * 2 * t)\n\ncoupling_dict = {(0, 1): g,\n                 (0, 2): -g} # for phi=0 the coupling strengths need different signs\n</pre> transmon_dict = {             0: {\"frequency\": 5.0, \"anharmonicity\": 0.3},             1: {\"frequency\": 5.4, \"anharmonicity\": 0.3},             2: {\"frequency\": 5.2, \"anharmonicity\": 0.3},         }  # Times in (ns) t = 100  # corresponding coupling g = 1 / (np.sqrt(2) * 2 * t)  coupling_dict = {(0, 1): g,                  (0, 2): -g} # for phi=0 the coupling strengths need different signs In\u00a0[25]: Copied! <pre># Load the physical parameters onto the model\nmodel = SarimnerModel(\n    transmon_dict=transmon_dict,\n    coupling_dict=coupling_dict\n)\noptions = {\n    \"dt\": 0.1,\n    \"two_qubit_gate\": {\n        \"buffer_time\": 0,\n        \"rise_fall_time\": 0.1,\n    },\n}\n# Choose compiler\ncompiler = SarimnerCompiler(model=model, options=options)\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, compiler=compiler, noise=[])\n</pre> # Load the physical parameters onto the model model = SarimnerModel(     transmon_dict=transmon_dict,     coupling_dict=coupling_dict ) options = {     \"dt\": 0.1,     \"two_qubit_gate\": {         \"buffer_time\": 0,         \"rise_fall_time\": 0.1,     }, } # Choose compiler compiler = SarimnerCompiler(model=model, options=options) # Create the processor with the given hardware parameters sarimner = SarimnerProcessor(model=model, compiler=compiler, noise=[]) In\u00a0[26]: Copied! <pre>tlist, coeffs = sarimner.load_circuit(circuit)\n</pre> tlist, coeffs = sarimner.load_circuit(circuit) In\u00a0[27]: Copied! <pre>sarimner.plot_pulses(show_axis=True);\n</pre> sarimner.plot_pulses(show_axis=True); In\u00a0[28]: Copied! <pre>ket110 = tensor([basis(3,1),basis(3,1),basis(3,0)])\nket101 = tensor([basis(3,1),basis(3,0),basis(3,1)])\nket200 = tensor([basis(3,2),basis(3,0),basis(3,0)])\ne_ops = [ket2dm(ket110), ket2dm(ket101), ket2dm(ket200)]\nresult = sarimner.run_state(ket110, e_ops=e_ops, options={'store_states':True, 'nsteps':1e5, 'atol': 1e-12})\n</pre> ket110 = tensor([basis(3,1),basis(3,1),basis(3,0)]) ket101 = tensor([basis(3,1),basis(3,0),basis(3,1)]) ket200 = tensor([basis(3,2),basis(3,0),basis(3,0)]) e_ops = [ket2dm(ket110), ket2dm(ket101), ket2dm(ket200)] result = sarimner.run_state(ket110, e_ops=e_ops, options={'store_states':True, 'nsteps':1e5, 'atol': 1e-12}) In\u00a0[29]: Copied! <pre>import matplotlib.pyplot as plt\nplt.plot(result.times,result.expect[0], label=\"110\")\nplt.plot(result.times,result.expect[1], label=\"101\")\nplt.plot(result.times,result.expect[2], label=\"200\")\nplt.legend()\n</pre> import matplotlib.pyplot as plt plt.plot(result.times,result.expect[0], label=\"110\") plt.plot(result.times,result.expect[1], label=\"101\") plt.plot(result.times,result.expect[2], label=\"200\") plt.legend() Out[29]: <pre>&lt;matplotlib.legend.Legend at 0x1640576d0&gt;</pre> <p>Using the <code>run_propagator</code> method we can compute the propagator of the evolution.</p> In\u00a0[30]: Copied! <pre>prop = sarimner.run_propagator(options={\"nsteps\":1e5})\nprop = project_on_qubit(prop)\nprop\n</pre> prop = sarimner.run_propagator(options={\"nsteps\":1e5}) prop = project_on_qubit(prop) prop Out[30]:  Quantum object: dims=[[2, 2, 2], [2, 2, 2]], shape=(8, 8), type='oper', dtype=Dense, isherm=False$$\\left(\\begin{array}{cc}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 6.671\\times10^{ -6 } &amp; 1.000 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1.000 &amp; 6.671\\times10^{ -6 } &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1.000\\end{array}\\right)$$  <p>We can then compute the average gate fidelity between the ideal gate and the simulated gate</p> In\u00a0[31]: Copied! <pre>ideal_prop = cczs((np.pi / 2, 0, 0))\naverage_gate_fidelity(ideal_prop, prop)\n</pre> ideal_prop = cczs((np.pi / 2, 0, 0)) average_gate_fidelity(ideal_prop, prop) Out[31]: <pre>np.float64(0.9999940699864269)</pre>"},{"location":"examples/quantum_gates/#quantum-gates","title":"Quantum Gates\u00b6","text":""},{"location":"examples/quantum_gates/#single-qubit-gate-example","title":"Single Qubit Gate Example\u00b6","text":"<p>We begin by creating a quantum circuit that has a single-qubit, and we perform a single-qubit gate on it</p>"},{"location":"examples/quantum_gates/#two-qubit-gate-example","title":"Two Qubit Gate Example\u00b6","text":""},{"location":"examples/quantum_gates/#three-qubit-gate-example","title":"Three Qubit Gate Example\u00b6","text":""},{"location":"examples/randomized_benchmarking/","title":"Randomized Benchmarking","text":"In\u00a0[1]: Copied! <pre>from chalmers_qubit.devices.sarimner import SarimnerProcessor, SarimnerModel, SarimnerCompiler, DecoherenceNoise\n\ntransmon_dict = {\n    0: {\"frequency\": 5.02, \"anharmonicity\": -0.3},\n}\ndecoherence_dict = {\n    0: {\"t1\": 60e3, \"t2\": 100e3},\n}\n\n# Set up the model, compiler, and processor\nmodel = SarimnerModel(transmon_dict=transmon_dict)\ncompiler = SarimnerCompiler(model=model)\nnoise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]\nsarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise)\n</pre> from chalmers_qubit.devices.sarimner import SarimnerProcessor, SarimnerModel, SarimnerCompiler, DecoherenceNoise  transmon_dict = {     0: {\"frequency\": 5.02, \"anharmonicity\": -0.3}, } decoherence_dict = {     0: {\"t1\": 60e3, \"t2\": 100e3}, }  # Set up the model, compiler, and processor model = SarimnerModel(transmon_dict=transmon_dict) compiler = SarimnerCompiler(model=model) noise = [DecoherenceNoise(decoherence_dict=decoherence_dict)] sarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise) <p>We now create the single-qubit Clifford group. The Clifford gate decomposition follows Ref. Epstein et al. Phys. Rev. A 89, 062321 (2014)</p> In\u00a0[2]: Copied! <pre>from qutip import basis, fidelity\nfrom chalmers_qubit.utils.randomized_benchmarking import RandomizedBenchmarking\n\nsequences = [8, 64, 128, 256, 512, 1024]\nsequence_fidelity = []\n\nrb = RandomizedBenchmarking(clifford_group=1)\n\n# Loop over sequence lengths\nfor m in sequences:\n    print(f\"Running sequence length {m}\")\n    \n    # Generate the randomized benchmarking circuit\n    clifford_qc = rb.randomized_benchmarking_circuit(\n        number_of_cliffords=m,\n        apply_inverse=True,\n    )\n    \n    # Simulate the quantum circuit and compute the probability of remaning in the initial state\n    init_state = basis(3,0)\n\n    result = sarimner.run_state(\n        init_state=init_state, \n        qc=clifford_qc\n    )\n\n    final_state = result.states[-1]\n\n    # Compute the survival probability\n    sequence_fidelity.append(fidelity(init_state, final_state))\n</pre> from qutip import basis, fidelity from chalmers_qubit.utils.randomized_benchmarking import RandomizedBenchmarking  sequences = [8, 64, 128, 256, 512, 1024] sequence_fidelity = []  rb = RandomizedBenchmarking(clifford_group=1)  # Loop over sequence lengths for m in sequences:     print(f\"Running sequence length {m}\")          # Generate the randomized benchmarking circuit     clifford_qc = rb.randomized_benchmarking_circuit(         number_of_cliffords=m,         apply_inverse=True,     )          # Simulate the quantum circuit and compute the probability of remaning in the initial state     init_state = basis(3,0)      result = sarimner.run_state(         init_state=init_state,          qc=clifford_qc     )      final_state = result.states[-1]      # Compute the survival probability     sequence_fidelity.append(fidelity(init_state, final_state)) <pre>Running sequence length 8\nRunning sequence length 64\n</pre> <pre>/Users/vikstal/miniconda3/envs/chalmers-qubit/lib/python3.10/site-packages/qutip-5.1.1-py3.10-macosx-11.1-arm64.egg/qutip/solver/options.py:16: FutureWarning: Dedicated options class are no longer needed, options should be passed as dict to solvers.\n  warnings.warn(\n</pre> <pre>Running sequence length 128\nRunning sequence length 256\nRunning sequence length 512\nRunning sequence length 1024\n</pre> In\u00a0[3]: Copied! <pre>import numpy as np\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\n\n# Define the model function\ndef model(m, A, p, B) -&gt; float:\n    return A * p**m + B\n\n# Initial guess for A, p, B\ninitial_guess = [1, 0.99, 0.5]\n\n# Fit the curve\nparams, covariance = curve_fit(model, sequences, sequence_fidelity, p0=initial_guess)\n\n# Extract fitted parameters\nA_fit, p_fit, B_fit = params\nprint(f\"A = {A_fit}, p = {p_fit}, B = {B_fit}\")\n\n# Plot\nx_fit = np.linspace(min(sequences), max(sequences), 100)\ny_fit = model(x_fit, A_fit, p_fit, B_fit)\n\nplt.scatter(sequences, sequence_fidelity, label=\"RB\")\nplt.plot(x_fit, y_fit, label=\"RB Fit\", color='red', linestyle='--')\nplt.legend()\nplt.xlabel(\"Number of Cliffords (m)\")\nplt.ylabel(\"Survival Probability\")\nplt.title(\"Single Clifford Randomized Benchmarking\")\nplt.xticks(sequences)\nplt.show()\n</pre> import numpy as np from scipy.optimize import curve_fit import matplotlib.pyplot as plt  # Define the model function def model(m, A, p, B) -&gt; float:     return A * p**m + B  # Initial guess for A, p, B initial_guess = [1, 0.99, 0.5]  # Fit the curve params, covariance = curve_fit(model, sequences, sequence_fidelity, p0=initial_guess)  # Extract fitted parameters A_fit, p_fit, B_fit = params print(f\"A = {A_fit}, p = {p_fit}, B = {B_fit}\")  # Plot x_fit = np.linspace(min(sequences), max(sequences), 100) y_fit = model(x_fit, A_fit, p_fit, B_fit)  plt.scatter(sequences, sequence_fidelity, label=\"RB\") plt.plot(x_fit, y_fit, label=\"RB Fit\", color='red', linestyle='--') plt.legend() plt.xlabel(\"Number of Cliffords (m)\") plt.ylabel(\"Survival Probability\") plt.title(\"Single Clifford Randomized Benchmarking\") plt.xticks(sequences) plt.show() <pre>A = 0.32003471479331824, p = 0.9991417999204416, B = 0.6793497994523574\n</pre> <p>Calculate the average error per clifford and average error per gate. The average error per gate is calculated by dividing the average error per clifford by the average number of physical gates per clifford. The average number of physical gates per clifford is calculated by taking the average number of gates in the decomposition of the clifford group.</p> In\u00a0[4]: Copied! <pre>r_clifford = 1 - p_fit - (1-p_fit) / 2\nprint(f\"Error per Clifford: {(r_clifford):.2e}\")\nprint(f\"Error per Gate: {(r_clifford / 1.875):.2e}\")\n</pre> r_clifford = 1 - p_fit - (1-p_fit) / 2 print(f\"Error per Clifford: {(r_clifford):.2e}\") print(f\"Error per Gate: {(r_clifford / 1.875):.2e}\") <pre>Error per Clifford: 4.29e-04\nError per Gate: 2.29e-04\n</pre> In\u00a0[5]: Copied! <pre>transmon_dict = {\n    0: {\"frequency\": 5.02, \"anharmonicity\": -0.3},\n    1: {\"frequency\": 4.82, \"anharmonicity\": -0.3},\n}\ndecoherence_dict = {\n    0: {\"t1\": 60e3, \"t2\": 100e3},\n    1: {\"t1\": 60e3, \"t2\": 100e3},\n}\n\n# The time for the CZ-gate that we want in (ns)\nt = 100\n\n# Corresponding coupling in (GHz)\ng = 1 / (np.sqrt(2) * 2 * t)\n\ncoupling_dict = {\n    (0, 1): g,\n}\n\n# Set up the model, compiler, and processor\nmodel = SarimnerModel(transmon_dict=transmon_dict, coupling_dict=coupling_dict)\ncompiler = SarimnerCompiler(model=model)\nnoise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]\nsarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise)\n</pre> transmon_dict = {     0: {\"frequency\": 5.02, \"anharmonicity\": -0.3},     1: {\"frequency\": 4.82, \"anharmonicity\": -0.3}, } decoherence_dict = {     0: {\"t1\": 60e3, \"t2\": 100e3},     1: {\"t1\": 60e3, \"t2\": 100e3}, }  # The time for the CZ-gate that we want in (ns) t = 100  # Corresponding coupling in (GHz) g = 1 / (np.sqrt(2) * 2 * t)  coupling_dict = {     (0, 1): g, }  # Set up the model, compiler, and processor model = SarimnerModel(transmon_dict=transmon_dict, coupling_dict=coupling_dict) compiler = SarimnerCompiler(model=model) noise = [DecoherenceNoise(decoherence_dict=decoherence_dict)] sarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise) In\u00a0[6]: Copied! <pre>from qutip import tensor, basis, fidelity\nfrom qutip_qip.operations import CZ\nfrom chalmers_qubit.utils.randomized_benchmarking import RandomizedBenchmarking\n\nrb = RandomizedBenchmarking(clifford_group=2)\ndef run_rb_sequence(m, interleaved_gate=None):\n    \"\"\"Run a single RB sequence and return the survival probability.\"\"\"\n    print(f\"Running sequence length {m}\" + (\" (interleaved)\" if interleaved_gate else \"\"))\n    \n    # Generate the circuit\n    circuit = rb.randomized_benchmarking_circuit(\n        number_of_cliffords=m,\n        apply_inverse=True,\n        interleaved_clifford_gate=interleaved_gate\n    )\n    \n    # Simulate and compute fidelity\n    init_state = tensor([basis(3, 0), basis(3, 0)])\n    result = sarimner.run_state(init_state=init_state, qc=circuit)\n    final_state = result.states[-1]\n    \n    return fidelity(init_state, final_state)\n\n# Setup\nsequences = [8, 64, 128, 256]\ninterleaved_gate = CZ(controls=0, targets=1)\n\n# Run experiments\nsequence_fidelity = []\nsequence_fidelity_interleaved = []\n\nfor m in sequences:\n    # Standard RB\n    sequence_fidelity.append(\n        run_rb_sequence(m)\n    )\n    \n    # Interleaved RB\n    sequence_fidelity_interleaved.append(\n        run_rb_sequence(m, interleaved_gate)\n    )\n</pre> from qutip import tensor, basis, fidelity from qutip_qip.operations import CZ from chalmers_qubit.utils.randomized_benchmarking import RandomizedBenchmarking  rb = RandomizedBenchmarking(clifford_group=2) def run_rb_sequence(m, interleaved_gate=None):     \"\"\"Run a single RB sequence and return the survival probability.\"\"\"     print(f\"Running sequence length {m}\" + (\" (interleaved)\" if interleaved_gate else \"\"))          # Generate the circuit     circuit = rb.randomized_benchmarking_circuit(         number_of_cliffords=m,         apply_inverse=True,         interleaved_clifford_gate=interleaved_gate     )          # Simulate and compute fidelity     init_state = tensor([basis(3, 0), basis(3, 0)])     result = sarimner.run_state(init_state=init_state, qc=circuit)     final_state = result.states[-1]          return fidelity(init_state, final_state)  # Setup sequences = [8, 64, 128, 256] interleaved_gate = CZ(controls=0, targets=1)  # Run experiments sequence_fidelity = [] sequence_fidelity_interleaved = []  for m in sequences:     # Standard RB     sequence_fidelity.append(         run_rb_sequence(m)     )          # Interleaved RB     sequence_fidelity_interleaved.append(         run_rb_sequence(m, interleaved_gate)     )  <pre>Running sequence length 8\nRunning sequence length 8 (interleaved)\nRunning sequence length 64\nRunning sequence length 64 (interleaved)\nRunning sequence length 128\nRunning sequence length 128 (interleaved)\nRunning sequence length 256\nRunning sequence length 256 (interleaved)\n</pre> In\u00a0[7]: Copied! <pre>import numpy as np\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\n\n# Define the model function\ndef model(m, A, p, B) -&gt; float:\n    return A * p**m + B\n\n# Initial guess for A, p, B\ninitial_guess = [1, 0.99, 0.5]\n\n# Fit the curve\nparams, covariance = curve_fit(model, sequences, sequence_fidelity, p0=initial_guess)\n\n# Fit the curve\nparams_interleaved, covariance_interleaved = curve_fit(model, sequences, sequence_fidelity_interleaved, p0=initial_guess)\n\n# Extract fitted parameters\nA_fit, p_fit, B_fit = params\nprint(f\"A = {A_fit}, p = {p_fit}, B = {B_fit}\")\n\nA_interleaved_fit, p_interleaved_fit, B_interleaved_fit = params_interleaved\nprint(f\"A (int) = {A_interleaved_fit}, p (int) = {p_interleaved_fit}, B (int) = {B_interleaved_fit}\")\n\n# Plot\nx_fit = np.linspace(min(sequences), max(sequences), 100)\ny_fit = model(x_fit, A_fit, p_fit, B_fit)\n\ny_interleaved_fit = model(x_fit, A_interleaved_fit, p_interleaved_fit, B_interleaved_fit)\n\nplt.scatter(sequences, sequence_fidelity, label=\"RB\")\nplt.scatter(sequences, sequence_fidelity_interleaved, label=\"Interleaved (CZ) RB\")\nplt.plot(x_fit, y_fit, label=\"RB Fit\", color='red', linestyle='--')\nplt.plot(x_fit, y_interleaved_fit, label=\"Interleaved (CZ) Fit\", color='red')\nplt.legend()\nplt.xlabel(\"Number of Cliffords (m)\")\nplt.ylabel(\"Survival Probability\")\nplt.title(\"Two Qubit Clifford Interleaved Randomized Benchmarking\")\nplt.xticks(sequences)\nplt.show()\n</pre> import numpy as np from scipy.optimize import curve_fit import matplotlib.pyplot as plt  # Define the model function def model(m, A, p, B) -&gt; float:     return A * p**m + B  # Initial guess for A, p, B initial_guess = [1, 0.99, 0.5]  # Fit the curve params, covariance = curve_fit(model, sequences, sequence_fidelity, p0=initial_guess)  # Fit the curve params_interleaved, covariance_interleaved = curve_fit(model, sequences, sequence_fidelity_interleaved, p0=initial_guess)  # Extract fitted parameters A_fit, p_fit, B_fit = params print(f\"A = {A_fit}, p = {p_fit}, B = {B_fit}\")  A_interleaved_fit, p_interleaved_fit, B_interleaved_fit = params_interleaved print(f\"A (int) = {A_interleaved_fit}, p (int) = {p_interleaved_fit}, B (int) = {B_interleaved_fit}\")  # Plot x_fit = np.linspace(min(sequences), max(sequences), 100) y_fit = model(x_fit, A_fit, p_fit, B_fit)  y_interleaved_fit = model(x_fit, A_interleaved_fit, p_interleaved_fit, B_interleaved_fit)  plt.scatter(sequences, sequence_fidelity, label=\"RB\") plt.scatter(sequences, sequence_fidelity_interleaved, label=\"Interleaved (CZ) RB\") plt.plot(x_fit, y_fit, label=\"RB Fit\", color='red', linestyle='--') plt.plot(x_fit, y_interleaved_fit, label=\"Interleaved (CZ) Fit\", color='red') plt.legend() plt.xlabel(\"Number of Cliffords (m)\") plt.ylabel(\"Survival Probability\") plt.title(\"Two Qubit Clifford Interleaved Randomized Benchmarking\") plt.xticks(sequences) plt.show()  <pre>A = 0.558311459649314, p = 0.9944274532179266, B = 0.4401895781209156\nA (int) = 0.5292527547296116, p (int) = 0.9917872904374351, B (int) = 0.4751128640394195\n</pre> In\u00a0[8]: Copied! <pre># Calculate average error per CZ gate\nd = 4\nr_cz = (d - 1)/d * (1 - p_interleaved_fit/p_fit)\nprint(f\"Average error per CZ gate: {(r_cz):.2e}\")\n</pre> # Calculate average error per CZ gate d = 4 r_cz = (d - 1)/d * (1 - p_interleaved_fit/p_fit) print(f\"Average error per CZ gate: {(r_cz):.2e}\") <pre>Average error per CZ gate: 1.99e-03\n</pre>"},{"location":"examples/randomized_benchmarking/#randomized-benchmarking","title":"Randomized Benchmarking\u00b6","text":""},{"location":"examples/randomized_benchmarking/#single-qubit-clifford-randomized-benchmarking","title":"Single-Qubit Clifford Randomized Benchmarking\u00b6","text":"<p>Randomized benchmarking is a technique used to estimate the average fidelity of quantum gates. The basic idea is to apply a sequence of random gates, followed by an inverse gate that should ideally return the system to its original state. By measuring the fidelity of the final state, one can infer the average error of the gates used in the sequence.m</p> <p>Performing long sequences of random Clifford gates uniformly sampled from the Clifford group result in an exponential decay of the survival probability. The exponential decay (also called average sequence fidelity or survival rate) $F$ should be fit to</p> <p>$$ F(m)= Ap^m + B $$</p> <p>where $m$ is the number of Cliffords in the sequence, $A$ and $B$ are parameters related to state preparation and measurement, and $1-p$ is the depolarization rate. Using $p$, the average gate error per Clifford, $r_\\mathrm{Clifford}$, can be computed as</p> <p>$$ r_\\mathrm{Clifford} = 1-p-\\frac{1-p}{d} $$</p> <p>where $d=2^N$ is the dimension of the Clifford gates for $N$ qubits. By dividing the Clifford error by the average number of physical gates per Clifford, the error per gate, $r_\\mathrm{gate}$  can be obtained.</p> <p>The Clifford Randomized Benchmarking protocol can be summarized as follows:</p> <ol> <li>Initialize the qubit in the ground state.</li> <li>Apply a sequence of $m$ Cliffords to the qubit.</li> <li>Apply an additional $(m+1)$ gate which inverts the whole sequence.</li> <li>Measure the resulting ground state probability.</li> <li>Repeat this procedure $k$ times.</li> <li>Repeat for multiple lengths $m$ to build up an exponential decay.</li> </ol>"},{"location":"examples/randomized_benchmarking/#setup-a-single-qubit-device","title":"Setup a single-qubit device\u00b6","text":""},{"location":"examples/randomized_benchmarking/#loop-over-sequences","title":"Loop over sequences\u00b6","text":""},{"location":"examples/randomized_benchmarking/#fit-the-data-to-an-exponential-decay","title":"Fit the data to an exponential decay\u00b6","text":"<p>We fit the exponential decay (also called average sequence fidelity or survival rate) $F$ to</p> <p>$$ F(m)= Ap^m + B $$</p>"},{"location":"examples/randomized_benchmarking/#two-qubit-interleaved-randomized-benchmarking","title":"Two-Qubit Interleaved Randomized Benchmarking\u00b6","text":"<p>The interleaved Clifford randomized benchmarking (RB) gate error provides an estimate for the average error of a target Clifford gate in a gate set.</p> <p>Clifford RB provides the average gate error over all of the gates in the gate set used to decompose the Clifford gates. In contrast, interleaved Clifford RB characterizes the average error of a specific Clifford gate, which is interleaved through the random Clifford sequences used in RB. If the RB random Clifford gate sequence is expressed as:</p> <p>$$ C_1C_2\\ldots C_m C_\\mathrm{inverse}, $$</p> <p>where each $C$ is a Clifford gate, then the interleaved RB sequence can be written as:</p> <p>$$ C_1C_\\mathrm{target}C_2C_\\mathrm{target}\\ldots C_mC_\\mathrm{target}C'_\\mathrm{inverse} $$</p> <p>where $C_\\mathrm{target}$ is the gate to characterize and must also be part of the Clifford group. Additionally, the final inverting gate must be updated to invert the full gate sequence including $C_\\mathrm{target}$. The specific gate error is obtained by comparing the decay parameters in $F(m)$ for both the non-interleaved and interleaved RB results.</p> <p>The fitted decay parameters from the non-interleaved RB and the interleaved RB are denoted by $p$ (or $p_\\mathrm{reference}$ in some sources) and $p_\\mathrm{interleaved}$ respectively. Then, the interleaved RB gate error for $C_\\mathrm{target}$ is found using</p> <p>$$ r_{C_\\mathrm{target}}=\\frac{(d-1)(1-\\frac{p_\\mathrm{interleaved}}{p})}{d} $$</p>"},{"location":"examples/randomized_benchmarking/#setup-a-two-qubit-device","title":"Setup a two-qubit device\u00b6","text":""},{"location":"examples/randomized_benchmarking/#fit-the-data-to-an-exponential-decay","title":"Fit the data to an exponential decay\u00b6","text":""},{"location":"examples/relaxation/","title":"Relaxation","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nfrom qutip import Qobj, basis, destroy, tensor\nfrom chalmers_qubit.devices.sarimner.processor import SarimnerProcessor\nfrom chalmers_qubit.devices.sarimner.model import SarimnerModel\nfrom chalmers_qubit.devices.sarimner.noise import DecoherenceNoise, ZZCrossTalk\nfrom chalmers_qubit.utils.operations import project_on_qubit\n\nimport warnings\nwarnings.simplefilter(action=\"ignore\", category=FutureWarning)\n\n%load_ext autoreload\n%autoreload 2\n</pre> import matplotlib.pyplot as plt import numpy as np from qutip import Qobj, basis, destroy, tensor from chalmers_qubit.devices.sarimner.processor import SarimnerProcessor from chalmers_qubit.devices.sarimner.model import SarimnerModel from chalmers_qubit.devices.sarimner.noise import DecoherenceNoise, ZZCrossTalk from chalmers_qubit.utils.operations import project_on_qubit  import warnings warnings.simplefilter(action=\"ignore\", category=FutureWarning)  %load_ext autoreload %autoreload 2 <p>Initializing the Qubit System</p> <p>We start by initializing the parameters of our qubit system: the number of qubits, their frequencies, anharmonicities, and relaxation times $T_1$ and $T_2$. These parameters are essential for accurately modeling the qubit's physical behavior in our simulation. We create a <code>SarimnerProcessor</code> instance with these specified parameters to represent our qubit processor.</p> In\u00a0[2]: Copied! <pre>transmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n}\ndecoherence_dict = {\n    0: {\"t1\": 60e3, \"t2\": 80e3},\n}\n</pre> transmon_dict = {     0: {\"frequency\": 5.0, \"anharmonicity\": -0.30}, } decoherence_dict = {     0: {\"t1\": 60e3, \"t2\": 80e3}, } In\u00a0[3]: Copied! <pre># Create the processor with the given hardware parameters\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n\n# Add noise\nnoise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, noise=noise)\n</pre> # Create the processor with the given hardware parameters # Load the physical parameters onto the model model = SarimnerModel(transmon_dict=transmon_dict)  # Add noise noise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]  # Create the processor with the given hardware parameters sarimner = SarimnerProcessor(model=model, noise=noise) <p>Simulating the Qubit System</p> <p>Next, we simulate the master equation to study the qubit's dynamics over time. The simulation begins with the qubit in its excited state, represented by <code>rho</code>. We aim to observe how the qubit relaxes back to its ground state over a total time of 200 ns, sampled at 30 points (<code>tlist</code>) by measuring the expecation value of the number operator $\\hat a^\\dagger \\hat a$.</p> In\u00a0[4]: Copied! <pre># master equation simulation\nvac = basis(3,0)\na = destroy(3)\nrho = a.dag() * vac\ne_ops = [a.dag()*a]\nt_total = 200*1e3\ntlist = np.linspace(0,t_total,30)\nresult = sarimner.run_state(rho, tlist=tlist, e_ops=e_ops)\n</pre> # master equation simulation vac = basis(3,0) a = destroy(3) rho = a.dag() * vac e_ops = [a.dag()*a] t_total = 200*1e3 tlist = np.linspace(0,t_total,30) result = sarimner.run_state(rho, tlist=tlist, e_ops=e_ops) <p>Plotting the Results</p> <p>Finally we can visualize the qubit's relaxation process and compare the simulation results with the theoretical prediction.</p> In\u00a0[5]: Copied! <pre>t = np.array(result.times)\nt1 = decoherence_dict[0][\"t1\"]\nplt.figure(1)\nplt.plot(t/1e3, result.e_data[0], '.', linewidth=.5, label= r'simulation')\nplt.plot(t/1e3, np.exp(-t/t1), '--', linewidth=1, label=r'theory, $\\exp(-t/T1)$')\nplt.yticks([0,1],[r'$|0\\rangle$',r'$|1\\rangle$'])\nplt.xlabel(r\"Time (\u03bcs)\")\nplt.ylabel(r'Population')\nplt.legend();\n</pre> t = np.array(result.times) t1 = decoherence_dict[0][\"t1\"] plt.figure(1) plt.plot(t/1e3, result.e_data[0], '.', linewidth=.5, label= r'simulation') plt.plot(t/1e3, np.exp(-t/t1), '--', linewidth=1, label=r'theory, $\\exp(-t/T1)$') plt.yticks([0,1],[r'$|0\\rangle$',r'$|1\\rangle$']) plt.xlabel(r\"Time (\u03bcs)\") plt.ylabel(r'Population') plt.legend(); <p>The following is an example of how to measure the transversal relaxation of the qubit.</p> In\u00a0[6]: Copied! <pre>transmon_dict_rot = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n}\n\n# Create the processor with the given hardware parameters\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict_rot)\n\n# Add noise\nnoise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, noise=noise)\n</pre> transmon_dict_rot = {     0: {\"frequency\": 5.0, \"anharmonicity\": -0.30}, }  # Create the processor with the given hardware parameters # Load the physical parameters onto the model model = SarimnerModel(transmon_dict=transmon_dict_rot)  # Add noise noise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]  # Create the processor with the given hardware parameters sarimner = SarimnerProcessor(model=model, noise=noise) <p>Next, we prepare the qubit in the plus-state that lies along the positive x-axis on the Bloch sphere, and we measure the expectation value of the number operator in the $X$-basis.</p> In\u00a0[7]: Copied! <pre>from qutip import Options\n# Prepare qubit in plus state\nrho = (basis(3,1) + basis(3,0)).unit()\nHadamard = 1/np.sqrt(2) * Qobj([[1,1,0],[1,-1,0],[0,0,0]])\ne_ops = [Hadamard*a.dag()*a*Hadamard]\n# Transmon Hamiltonian with a slight detuning\nt_total = 200 * 1e3 # in (ns)\ntlist = np.linspace(0, t_total, 500)\n# master equation simulation\nresult = sarimner.run_state(rho, tlist=tlist, e_ops=e_ops, options=Options(nsteps=1e5))\n</pre> from qutip import Options # Prepare qubit in plus state rho = (basis(3,1) + basis(3,0)).unit() Hadamard = 1/np.sqrt(2) * Qobj([[1,1,0],[1,-1,0],[0,0,0]]) e_ops = [Hadamard*a.dag()*a*Hadamard] # Transmon Hamiltonian with a slight detuning t_total = 200 * 1e3 # in (ns) tlist = np.linspace(0, t_total, 500) # master equation simulation result = sarimner.run_state(rho, tlist=tlist, e_ops=e_ops, options=Options(nsteps=1e5)) <p>Finally, we plot the results and compare the simulation to our theoretical prediction.</p> In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots()\nt2 = decoherence_dict[0][\"t2\"]\n# detail about lenght of tlist needs to be fixed\nax.plot(tlist/1e3, result.expect[0], '.', linewidth = .5, label=\"simulation\")\nax.plot(tlist/1e3, -(np.exp(-tlist/(t2))-1)/2, '--', linewidth = 1, label=r\"theory, $\\exp(-t/T2^*)$\")\nplt.yticks([0,.5,1], [r'$|0\\rangle$','',r'$|1\\rangle$'])\nplt.xlabel(r\"Time (\u03bcs)\")\nplt.ylabel(r\"Ramsey signal\")\nplt.legend()\n</pre> fig, ax = plt.subplots() t2 = decoherence_dict[0][\"t2\"] # detail about lenght of tlist needs to be fixed ax.plot(tlist/1e3, result.expect[0], '.', linewidth = .5, label=\"simulation\") ax.plot(tlist/1e3, -(np.exp(-tlist/(t2))-1)/2, '--', linewidth = 1, label=r\"theory, $\\exp(-t/T2^*)$\") plt.yticks([0,.5,1], [r'$|0\\rangle$','',r'$|1\\rangle$']) plt.xlabel(r\"Time (\u03bcs)\") plt.ylabel(r\"Ramsey signal\") plt.legend() Out[8]: <pre>&lt;matplotlib.legend.Legend at 0x11fc913c0&gt;</pre> In\u00a0[9]: Copied! <pre>from qutip_qip.circuit import QubitCircuit\n\ndef spin_echo(tau):\n    circuit = QubitCircuit(1)\n    circuit.add_gate(\"RX\", targets=0, arg_value=np.pi / 2)\n    circuit.add_gate(\"IDLE\", targets=0, arg_value=tau/2)\n    circuit.add_gate(\"RX\", targets=0, arg_value=np.pi)\n    circuit.add_gate(\"IDLE\", targets=0, arg_value=tau/2)\n    circuit.add_gate(\"RX\", targets=0, arg_value=np.pi/2)\n    return circuit\n</pre> from qutip_qip.circuit import QubitCircuit  def spin_echo(tau):     circuit = QubitCircuit(1)     circuit.add_gate(\"RX\", targets=0, arg_value=np.pi / 2)     circuit.add_gate(\"IDLE\", targets=0, arg_value=tau/2)     circuit.add_gate(\"RX\", targets=0, arg_value=np.pi)     circuit.add_gate(\"IDLE\", targets=0, arg_value=tau/2)     circuit.add_gate(\"RX\", targets=0, arg_value=np.pi/2)     return circuit In\u00a0[10]: Copied! <pre># Create the processor with the given hardware parameters\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n\n# Add noise\nnoise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, noise=noise)\n</pre> # Create the processor with the given hardware parameters # Load the physical parameters onto the model model = SarimnerModel(transmon_dict=transmon_dict)  # Add noise noise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]  # Create the processor with the given hardware parameters sarimner = SarimnerProcessor(model=model, noise=noise) In\u00a0[11]: Copied! <pre># Initial state for the simulation.\ninit_state = basis(3, 0)\n# Time list in (ns)\ntlist = np.linspace(0,100*1e3,10)\n# Expectation value of number operator\ne_ops = [destroy(3).dag()*destroy(3)]\n# Population\npop = []\n# Total time\ntotal_time = []\n# Loop over times\nfor tau in tlist:\n    times, coeffs = sarimner.load_circuit(spin_echo(tau))\n    # Get total time of simulation\n    t_total = sarimner.get_full_tlist()[-1]\n    # Run master equation simulation and save only start and end times\n    result = sarimner.run_state(init_state, tlist=[0,t_total] , e_ops=e_ops, options=Options(nsteps=5e6))\n    # Get result\n    pop.append(result.expect[0][-1])\n    total_time.append(t_total)\n</pre> # Initial state for the simulation. init_state = basis(3, 0) # Time list in (ns) tlist = np.linspace(0,100*1e3,10) # Expectation value of number operator e_ops = [destroy(3).dag()*destroy(3)] # Population pop = [] # Total time total_time = [] # Loop over times for tau in tlist:     times, coeffs = sarimner.load_circuit(spin_echo(tau))     # Get total time of simulation     t_total = sarimner.get_full_tlist()[-1]     # Run master equation simulation and save only start and end times     result = sarimner.run_state(init_state, tlist=[0,t_total] , e_ops=e_ops, options=Options(nsteps=5e6))     # Get result     pop.append(result.expect[0][-1])     total_time.append(t_total) In\u00a0[12]: Copied! <pre>t2 = decoherence_dict[0][\"t2\"]\nplt.plot(np.array(total_time)/1e3, 1-np.array(pop), '.', label='simulation')\nplt.plot(np.array(total_time)/1e3, (np.exp(-np.array(total_time)/(t2))+1)/2, 'r--', linewidth = 1, label=r\"theory, $\\exp(-t/T2^*)$\")\nplt.xlabel(r\"Time (\u03bcs)\")\nplt.ylabel(r\"Population\")\nplt.yticks([0, 1], [r\"$|0\\rangle$\", r\"$|1\\rangle$\"]);\nplt.legend()\n</pre> t2 = decoherence_dict[0][\"t2\"] plt.plot(np.array(total_time)/1e3, 1-np.array(pop), '.', label='simulation') plt.plot(np.array(total_time)/1e3, (np.exp(-np.array(total_time)/(t2))+1)/2, 'r--', linewidth = 1, label=r\"theory, $\\exp(-t/T2^*)$\") plt.xlabel(r\"Time (\u03bcs)\") plt.ylabel(r\"Population\") plt.yticks([0, 1], [r\"$|0\\rangle$\", r\"$|1\\rangle$\"]); plt.legend() Out[12]: <pre>&lt;matplotlib.legend.Legend at 0x11fd78d60&gt;</pre> <p>ZZ-crosstalk is a phenomenon in quantum computing, particularly relevant in systems with superconducting qubits, where the interaction between two or more qubits leads to unwanted phase shifts in the qubits that are not being directly operated upon. This effect arises due to the residual coupling between qubits, even when they are not intentionally interacting. The \"ZZ\" refers to the interaction type, denoting the direct coupling between the Z components of the qubit state. ZZ-crosstalk lead to coherent phase errors</p> In\u00a0[13]: Copied! <pre>transmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n    1: {\"frequency\": 5.4, \"anharmonicity\": -0.30},\n}\ncross_talk_dict = {(0,1): 1e-3}\n</pre> transmon_dict = {     0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},     1: {\"frequency\": 5.4, \"anharmonicity\": -0.30}, } cross_talk_dict = {(0,1): 1e-3} In\u00a0[14]: Copied! <pre># Create the processor with the given hardware parameters\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n\n# Add noise\nnoise = [ZZCrossTalk(cross_talk_dict=cross_talk_dict)]\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, noise=noise)\n</pre> # Create the processor with the given hardware parameters # Load the physical parameters onto the model model = SarimnerModel(transmon_dict=transmon_dict)  # Add noise noise = [ZZCrossTalk(cross_talk_dict=cross_talk_dict)]  # Create the processor with the given hardware parameters sarimner = SarimnerProcessor(model=model, noise=noise) In\u00a0[15]: Copied! <pre># Prepare qubit in 11 state\nrho = tensor(basis(3,1), basis(3,1))\n# Transmon Hamiltonian with a slight detuning\nt_total = 400 # in (ns)\ntlist = np.linspace(0, t_total, 500)\n# master equation simulation\nresult = sarimner.run_state(rho, tlist=tlist)\n</pre> # Prepare qubit in 11 state rho = tensor(basis(3,1), basis(3,1)) # Transmon Hamiltonian with a slight detuning t_total = 400 # in (ns) tlist = np.linspace(0, t_total, 500) # master equation simulation result = sarimner.run_state(rho, tlist=tlist) In\u00a0[16]: Copied! <pre>project_on_qubit(result.states[-1])\n</pre> project_on_qubit(result.states[-1]) Out[16]:  Quantum object: dims=[[2, 2], [1, 1]], shape=(4, 1), type='ket', dtype=Dense$$\\left(\\begin{array}{cc}0\\\\0\\\\0\\\\(-0.809-0.588j)\\end{array}\\right)$$  <p>Compute what the expected phase is</p> In\u00a0[17]: Copied! <pre>zz = cross_talk_dict[(0,1)]\nnp.around(np.exp(-1j*2*np.pi*zz*t_total),3)\n</pre> zz = cross_talk_dict[(0,1)] np.around(np.exp(-1j*2*np.pi*zz*t_total),3) Out[17]: <pre>np.complex128(-0.809-0.588j)</pre>"},{"location":"examples/relaxation/#relaxation","title":"Relaxation\u00b6","text":""},{"location":"examples/relaxation/#longitudinal-relaxation","title":"Longitudinal relaxation\u00b6","text":""},{"location":"examples/relaxation/#transversal-relaxation","title":"Transversal relaxation\u00b6","text":""},{"location":"examples/relaxation/#hahn-echo","title":"Hahn-Echo\u00b6","text":""},{"location":"examples/relaxation/#zz-crosstalk","title":"ZZ-crosstalk\u00b6","text":""},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>devices<ul> <li>sarimner<ul> <li>compiler</li> <li>model</li> <li>noise</li> <li>processor</li> </ul> </li> </ul> </li> <li>utils<ul> <li>gates</li> <li>operations</li> <li>randomized_benchmarking<ul> <li>clifford_group</li> <li>pauli_transfer_matrices</li> <li>randomized_benchmarking</li> </ul> </li> <li>transformation</li> </ul> </li> </ul>"},{"location":"reference/devices/sarimner/compiler/","title":"compiler","text":""},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler","title":"chalmers_qubit.devices.sarimner.compiler","text":"<p>Classes:</p> Name Description <code>SarimnerCompiler</code> <p>Compiler for :class:<code>.SarimnerModel</code>.</p>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler","title":"SarimnerCompiler","text":"<pre><code>SarimnerCompiler(\n    model: Model, options: Optional[dict] = None\n)\n</code></pre> <p>               Bases: <code>GateCompiler</code></p> <p>Compiler for :class:<code>.SarimnerModel</code>. Frequencies are the unit of GHz and times in ns.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Model object of the superconducting qubit device with hardware parameters.</p> required <code>options</code> <code>Optional[dict]</code> <p>A dictionary of compiler options. If not provided, default options will be used.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>num_qubits</code> <code>int</code> <p>The number of component systems (qubits).</p> <code>params</code> <code>dict</code> <p>A Python dictionary containing the name and value of hardware parameters, such as qubit frequency, anharmonicity, etc.</p> <code>gate_compiler</code> <code>dict</code> <p>A Python dictionary in the form of {gate_name: decompose_function}. It stores the decomposition scheme for each supported gate.</p> <code>phase</code> <code>list</code> <p>List of values indicating how much we have virtually rotated the Bloch sphere of each qubit.</p> <code>global_phase</code> <code>float</code> <p>The global phase of the quantum state.</p> <code>dt</code> <code>float</code> <p>Time step in nanoseconds.</p> <code>two_qubit_gate_options</code> <code>dict</code> <p>Options specific to two-qubit gates, including buffer_time and rise_fall_time.</p> <code>single_qubit_gate_options</code> <code>dict</code> <p>Options specific to single-qubit gates, including type, gate_time, pi-pulse amplitude, and std.</p> Notes <p>The compiler supports various gates including RZ, RX, RY, X, H, CZ, ISWAP, CCZS, IDLE, and GLOBALPHASE. Default options are provided for dt, two-qubit gates, and single-qubit gates, which can be overridden by passing custom options during initialization.</p> <p>Methods:</p> Name Description <code>cczs_compiler</code> <p>Compiler for CCZS gate.</p> <code>compile</code> <p>Compile the the native gates into control pulse sequence.</p> <code>cz_compiler</code> <p>Compiler for CZ gate.</p> <code>generate_pulse_shape</code> <p>Return a tuple consisting of a coeff list and a time sequence</p> <code>globalphase_compiler</code> <p>Compiler for the GLOBALPHASE gate</p> <code>h_compiler</code> <p>Compiler for the Hadamard gate</p> <code>idle_compiler</code> <p>Compiler for the IDLE gate</p> <code>iswap_compiler</code> <p>Compiler for ISWAP gate.</p> <code>rx_compiler</code> <p>Compiler for the RX gate</p> <code>ry_compiler</code> <p>Compiler for the RY gate</p> <code>rz_compiler</code> <p>Compiler for the Virtual-RZ gate</p> <code>x_compiler</code> <p>Compiler for the Hadamard gate</p>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.cczs_compiler","title":"cczs_compiler","text":"<pre><code>cczs_compiler(gate, args)\n</code></pre> <p>Compiler for CCZS gate.</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>:obj:`.Gate`:</code> <p>The quantum gate to be compiled.</p> required <code>args</code> <code>dict</code> <p>The compilation configuration defined in the attributes :obj:<code>.GateCompiler.args</code> or given as a parameter in :obj:<code>.GateCompiler.compile</code>.</p> required <p>Returns:</p> Type Description <code>A list of :obj:`.Instruction`, including the compiled pulse</code> <code>information for this gate.</code>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.compile","title":"compile","text":"<pre><code>compile(circuit, schedule_mode=None, args=None)\n</code></pre> <p>Compile the the native gates into control pulse sequence. It calls each compiling method and concatenates the compiled pulses.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <p>:class:<code>~.operations.Gate</code> A list of elementary gates that can be implemented in the corresponding hardware. The gate names have to be in <code>gate_compiler</code>.</p> required <code>schedule_mode</code> <p><code>\"ASAP\"</code> for \"as soon as possible\" or <code>\"ALAP\"</code> for \"as late as possible\" or <code>False</code> or <code>None</code> for no schedule. Default is None.</p> <code>None</code> <code>args</code> <p>A dictionary of arguments used in a specific gate compiler function.</p> <code>None</code> <p>Returns:</p> Type Description <code>tlist, coeffs: array_like or dict</code> <p>Compiled ime sequence and pulse coefficients. if <code>return_array</code> is true, return A 2d NumPy array of the shape <code>(len(ctrls), len(tlist))</code>. Each row corresponds to the control pulse sequence for one Hamiltonian. if <code>return_array</code> is false</p>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.cz_compiler","title":"cz_compiler","text":"<pre><code>cz_compiler(gate, args)\n</code></pre> <p>Compiler for CZ gate.</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>:obj:`.Gate`:</code> <p>The quantum gate to be compiled.</p> required <code>args</code> <code>dict</code> <p>The compilation configuration defined in the attributes :obj:<code>.GateCompiler.args</code> or given as a parameter in :obj:<code>.GateCompiler.compile</code>.</p> required <p>Returns:</p> Type Description <code>A list of :obj:`.Instruction`, including the compiled pulse</code> <code>information for this gate.</code>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.generate_pulse_shape","title":"generate_pulse_shape  <code>classmethod</code>","text":"<pre><code>generate_pulse_shape(\n    shape, num_samples, maximum=1.0, area=1.0\n)\n</code></pre> <p>Return a tuple consisting of a coeff list and a time sequence according to a given pulse shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>str</code> <p>The name <code>\"rectangular\"</code> for constant pulse or the name of a Scipy window function. See <code>the Scipy documentation &lt;https://docs.scipy.org/doc/scipy/reference/signal.windows.html&gt;</code>_ for detail.</p> required <code>num_samples</code> <code>int</code> <p>The number of the samples of the coefficients.</p> required <code>maximum</code> <code>float</code> <p>The maximum of the coefficients. The absolute value will be used if negative.</p> <code>1.0</code> <code>area</code> <code>float</code> <p>The total area if one integrates coeff as a function of the time. If the area is negative, the pulse is flipped vertically (i.e. the pulse is multiplied by the sign of the area).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>coeff, tlist :</code> <p>If the default window <code>\"shape\"=\"rectangular\"</code> is used, both are float numbers. If Scipy window functions are used, both are a 1-dimensional numpy array with the same size.</p> Notes <p>If Scipy window functions are used, it is suggested to set <code>Processor.pulse_mode</code> to <code>\"continuous\"</code>. Notice that finite number of sampling points will also make the total integral of the coefficients slightly deviate from <code>area</code>.</p> <p>Examples:</p> <p>.. plot::     :context: reset</p> <pre><code>from qutip_qip.compiler import GateCompiler\nimport numpy as np\ncompiler = GateCompiler()\ncoeff, tlist= compiler.generate_pulse_shape(\n    \"hann\",  # Scipy Hann window\n    1000,  # 100 sampling point\n    maximum=3.,\n    # Notice that 2 pi is added to H by qutip solvers.\n    area= 1.,\n)\n</code></pre> <p>We can plot the generated pulse shape:</p> <p>.. plot::     :context: close-figs</p> <pre><code>import matplotlib.pyplot as plt\nplt.plot(tlist, coeff)\nplt.show()\n</code></pre> <p>The pulse is normalized to fit the area. Notice that due to the finite number of sampling points, it is not exactly 1.</p> <p>.. testsetup::</p> <pre><code>from qutip_qip.compiler import GateCompiler\nimport numpy as np\ncompiler = GateCompiler()\ncoeff, tlist= compiler.generate_pulse_shape(\n    \"hann\",  # Scipy Hann window\n    1000,  # 100 sampling point\n    maximum=3.,\n    # Notice that 2 pi is added to H by qutip solvers.\n    area= 1.,\n)\n</code></pre> <p>.. doctest::</p> <pre><code>&gt;&gt;&gt; round(np.trapz(coeff, tlist), 2)\n1.0\n</code></pre>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.globalphase_compiler","title":"globalphase_compiler","text":"<pre><code>globalphase_compiler(gate, args)\n</code></pre> <p>Compiler for the GLOBALPHASE gate</p>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.h_compiler","title":"h_compiler","text":"<pre><code>h_compiler(gate, args)\n</code></pre> <p>Compiler for the Hadamard gate</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>:obj:`.Gate`:</code> <p>The quantum gate to be compiled.</p> required <code>args</code> <code>dict</code> <p>The compilation configuration defined in the attributes :obj:<code>.GateCompiler.args</code> or given as a parameter in :obj:<code>.GateCompiler.compile</code>.</p> required"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.idle_compiler","title":"idle_compiler","text":"<pre><code>idle_compiler(gate, args)\n</code></pre> <p>Compiler for the IDLE gate</p>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.iswap_compiler","title":"iswap_compiler","text":"<pre><code>iswap_compiler(gate, args)\n</code></pre> <p>Compiler for ISWAP gate.</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>:obj:`.Gate`:</code> <p>The quantum gate to be compiled.</p> required <code>args</code> <code>dict</code> <p>The compilation configuration defined in the attributes :obj:<code>.GateCompiler.args</code> or given as a parameter in :obj:<code>.GateCompiler.compile</code>.</p> required <p>Returns:</p> Type Description <code>A list of :obj:`.Instruction`, including the compiled pulse</code> <code>information for this gate.</code>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.rx_compiler","title":"rx_compiler","text":"<pre><code>rx_compiler(gate, args)\n</code></pre> <p>Compiler for the RX gate</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>:obj:`.Gate`:</code> <p>The quantum gate to be compiled.</p> required <code>args</code> <code>dict</code> <p>The compilation configuration defined in the attributes :obj:<code>.GateCompiler.args</code> or given as a parameter in :obj:<code>.GateCompiler.compile</code>.</p> required <p>Returns:</p> Type Description <code>A list of :obj:`.Instruction`, including the compiled pulse</code> <code>information for this gate.</code>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.ry_compiler","title":"ry_compiler","text":"<pre><code>ry_compiler(gate, args)\n</code></pre> <p>Compiler for the RY gate</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>:obj:`.Gate`:</code> <p>The quantum gate to be compiled.</p> required <code>args</code> <code>dict</code> <p>The compilation configuration defined in the attributes :obj:<code>.GateCompiler.args</code> or given as a parameter in :obj:<code>.GateCompiler.compile</code>.</p> required <p>Returns:</p> Type Description <code>A list of :obj:`.Instruction`, including the compiled pulse</code> <code>information for this gate.</code>"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.rz_compiler","title":"rz_compiler","text":"<pre><code>rz_compiler(gate, args)\n</code></pre> <p>Compiler for the Virtual-RZ gate</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>:obj:`.Gate`:</code> <p>The quantum gate to be compiled.</p> required <code>args</code> <code>dict</code> <p>The compilation configuration defined in the attributes :obj:<code>.GateCompiler.args</code> or given as a parameter in :obj:<code>.GateCompiler.compile</code>.</p> required"},{"location":"reference/devices/sarimner/compiler/#chalmers_qubit.devices.sarimner.compiler.SarimnerCompiler.x_compiler","title":"x_compiler","text":"<pre><code>x_compiler(gate, args)\n</code></pre> <p>Compiler for the Hadamard gate</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>:obj:`.Gate`:</code> <p>The quantum gate to be compiled.</p> required <code>args</code> <code>dict</code> <p>The compilation configuration defined in the attributes :obj:<code>.GateCompiler.args</code> or given as a parameter in :obj:<code>.GateCompiler.compile</code>.</p> required"},{"location":"reference/devices/sarimner/model/","title":"model","text":""},{"location":"reference/devices/sarimner/model/#chalmers_qubit.devices.sarimner.model","title":"chalmers_qubit.devices.sarimner.model","text":"<p>Classes:</p> Name Description <code>SarimnerModel</code> <p>Initializes a new quantum system simulation configuration for the Sarimner model.</p>"},{"location":"reference/devices/sarimner/model/#chalmers_qubit.devices.sarimner.model.SarimnerModel","title":"SarimnerModel","text":"<pre><code>SarimnerModel(\n    transmon_dict: dict,\n    coupling_dict: Optional[dict] = None,\n    dim: int = 3,\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Initializes a new quantum system simulation configuration for the Sarimner model.</p> <p>This class sets up the essential parameters and structure needed for simulating a quantum system with specified transmon qubit characteristics and couplings. It initializes the internal state required for managing the system's dynamics, including drift and controls.</p> <p>Parameters:</p> Name Type Description Default <code>transmon_dict</code> <code>dict</code> <p>A dictionary containing the parameters for each transmon qubit. The keys are qubit identifiers, and the values are dictionaries with qubit properties (e.g., frequency, anharmonicity).</p> required <code>coupling_dict</code> <code>Optional[dict]</code> <p>A dictionary specifying the couplings between qubits. If None, no couplings are considered.</p> <code>None</code> <code>dim</code> <code>int</code> <p>The dimension of the Hilbert space for each qubit (default is 3 for qutrit).</p> <code>3</code> <p>Attributes:</p> Name Type Description <code>num_qubits</code> <code>int</code> <p>The number of qubits in the system.</p> <code>dims</code> <code>list of int</code> <p>A list specifying the dimension of each qubit's Hilbert space.</p> <code>params</code> <code>dict</code> <p>A dictionary containing all system parameters, including transmon properties and couplings.</p> <code>_drift</code> <code>list</code> <p>Internal representation of the system's drift Hamiltonian.</p> <code>_controls</code> <code>dict</code> <p>Internal setup for system control Hamiltonians.</p> <code>_noise</code> <code>list</code> <p>An empty list initialized for potential future addition of noise models.</p> <p>Methods:</p> Name Description <code>_parse_dict</code> <p>Internal method to parse and validate input dictionaries.</p> <code>_set_up_drift</code> <p>Internal method to set up the drift Hamiltonian.</p> <code>_set_up_controls</code> <p>Internal method to set up the control Hamiltonians.</p> Notes <ul> <li>The <code>transmon_dict</code> should contain parameters for each qubit, such as frequency and anharmonicity.</li> <li>The <code>coupling_dict</code>, if provided, should specify the coupling strengths between qubit pairs.</li> <li>The model uses a fixed dimension (<code>dim</code>) for all qubits, defaulting to qutrit (3-level) systems.</li> </ul>"},{"location":"reference/devices/sarimner/model/#chalmers_qubit.devices.sarimner.model.SarimnerModel.get_all_drift","title":"get_all_drift","text":"<pre><code>get_all_drift() -&gt; List[Tuple[Qobj, List[int]]]\n</code></pre> <p>Get all the drift Hamiltonians.</p> <p>Returns:</p> Name Type Description <code>drift_hamiltonian_list</code> <code>list</code> <p>A list of drift Hamiltonians in the form of <code>[(qobj, targets), ...]</code>.</p>"},{"location":"reference/devices/sarimner/model/#chalmers_qubit.devices.sarimner.model.SarimnerModel.get_control","title":"get_control","text":"<pre><code>get_control(label: Hashable) -&gt; Tuple[Qobj, List[int]]\n</code></pre> <p>Get the control Hamiltonian corresponding to the label.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>hashable object</code> <p>A label that identifies the Hamiltonian.</p> required <p>Returns:</p> Name Type Description <code>control_hamiltonian</code> <code>tuple</code> <p>The control Hamiltonian in the form of <code>(qobj, targets)</code>.</p>"},{"location":"reference/devices/sarimner/model/#chalmers_qubit.devices.sarimner.model.SarimnerModel.get_control_labels","title":"get_control_labels","text":"<pre><code>get_control_labels() -&gt; List[Hashable]\n</code></pre> <p>Get a list of all available control Hamiltonians. Optional, required only when plotting the pulses or using the optimal control algorithm.</p> <p>Returns:</p> Name Type Description <code>label_list</code> <code>list of hashable objects</code> <p>A list of hashable objects each corresponds to an available control Hamiltonian.</p>"},{"location":"reference/devices/sarimner/model/#chalmers_qubit.devices.sarimner.model.SarimnerModel.get_control_latex","title":"get_control_latex","text":"<pre><code>get_control_latex()\n</code></pre> <p>Get the labels for each Hamiltonian. It is used in the method :meth:<code>.Processor.plot_pulses</code>. It is a 2-d nested list, in the plot, a different color will be used for each sublist.</p>"},{"location":"reference/devices/sarimner/model/#chalmers_qubit.devices.sarimner.model.SarimnerModel.get_noise","title":"get_noise","text":"<pre><code>get_noise() -&gt; List[Noise]\n</code></pre> <p>Get a list of :obj:<code>.Noise</code> objects. Single qubit relaxation (T1, T2) are not included here. Optional method.</p> <p>Returns:</p> Name Type Description <code>noise_list</code> <code>list</code> <p>A list of :obj:<code>.Noise</code>.</p>"},{"location":"reference/devices/sarimner/noise/","title":"noise","text":""},{"location":"reference/devices/sarimner/noise/#chalmers_qubit.devices.sarimner.noise","title":"chalmers_qubit.devices.sarimner.noise","text":"<p>Classes:</p> Name Description <code>DecoherenceNoise</code> <p>Represents decoherence noise in a quantum system, characterized by T1 and T2 times for each qubit.</p> <code>ZZCrossTalk</code> <p>A noise model representing always-on ZZ cross talk between qubits,</p>"},{"location":"reference/devices/sarimner/noise/#chalmers_qubit.devices.sarimner.noise.DecoherenceNoise","title":"DecoherenceNoise","text":"<pre><code>DecoherenceNoise(decoherence_dict: dict)\n</code></pre> <p>               Bases: <code>Noise</code></p> <p>Represents decoherence noise in a quantum system, characterized by T1 and T2 times for each qubit.</p> <p>This class models the decoherence effects on qubits in a quantum system. It allows for specifying individual T1 (relaxation) and T2 (dephasing) times for each qubit in the system.</p> <p>Parameters:</p> Name Type Description Default <code>decoherence_dict</code> <code>dict</code> <p>A dictionary specifying the decoherence parameters for each qubit. The keys should be qubit identifiers, and the values should be dictionaries containing 't1' and 't2' keys with their respective time values in nanoseconds.</p> required <p>Attributes:</p> Name Type Description <code>decoherence</code> <code>dict</code> <p>A dictionary storing the T1 and T2 values for each qubit in the system.</p> Example <pre><code>decoherence_dict = {\n    0: {'t1': 50e3, 't2': 70e3}, # values for the 0th qubit\n    1: {'t1': 45e3, 't2': 60e3} # values for the 1st qubit\n}\nnoise = [DecoherenceNoise(decoherence_dict)]\n</code></pre> Notes <ul> <li>T1 represents the relaxation time, which characterizes the time scale for energy dissipation.</li> <li>T2 represents the dephasing time, which characterizes the time scale for loss of phase coherence.</li> <li>T2 is always less than or equal to 2*T1.</li> </ul> <p>Methods:</p> Name Description <code>get_noisy_pulses</code> <p>Return the input pulses list with noise added and</p>"},{"location":"reference/devices/sarimner/noise/#chalmers_qubit.devices.sarimner.noise.DecoherenceNoise.get_noisy_pulses","title":"get_noisy_pulses","text":"<pre><code>get_noisy_pulses(\n    dims: list,\n    pulses: Optional[Pulse] = None,\n    systematic_noise: Optional[Pulse] = None,\n)\n</code></pre> <p>Return the input pulses list with noise added and the pulse independent noise in a dummy :class:<code>.Pulse</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>list</code> <p>The dimension of the components system.</p> required <code>pulses</code> <code>list of :class:`.Pulse`</code> <p>The input pulses. The noise will be added to pulses in this list.</p> <code>None</code> <code>systematic_noise</code> <code>:class:`.Pulse`</code> <p>The dummy pulse with no ideal control element.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>noisy_pulses</code> <code>list of :class:`.Pulse`</code> <p>Noisy pulses.</p> <code>systematic_noise</code> <code>:class:`.Pulse`</code> <p>The dummy pulse representing pulse-independent noise.</p>"},{"location":"reference/devices/sarimner/noise/#chalmers_qubit.devices.sarimner.noise.ZZCrossTalk","title":"ZZCrossTalk","text":"<pre><code>ZZCrossTalk(cross_talk_dict: dict)\n</code></pre> <p>               Bases: <code>Noise</code></p> <p>A noise model representing always-on ZZ cross talk between qubits, characterized by a cross-talk coefficient for each pair of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>cross_talk_dict</code> <code>dict</code> <p>A dictionary specifying the cross-talk strength between qubits. The keys are tuples (i, j), where <code>i</code> and <code>j</code> are qubit indices, and the corresponding value is the ZZ interaction strength between qubit <code>i</code> and qubit <code>j</code>.</p> required <p>Attributes:</p> Name Type Description <code>cross_talk_dict</code> <code>dict</code> <p>A dictionary representing the ZZ cross-talk interaction strengths between qubit pairs.</p> Notes <ul> <li>This model assumes that cross talk is always on, meaning it   continuously affects the qubits throughout their operation.</li> </ul> Example <pre><code>cross_talk_dict = {\n    (0, 1): 0.01,  # ZZ interaction strength between qubit 0 and qubit 1\n    (1, 2): 0.02,  # ZZ interaction strength between qubit 1 and qubit 2\n}\nnoise = [ZZCrossTalk(cross_talk)]\n</code></pre> <p>Methods:</p> Name Description <code>get_noisy_pulses</code> <p>Return the input pulses list with noise added and</p>"},{"location":"reference/devices/sarimner/noise/#chalmers_qubit.devices.sarimner.noise.ZZCrossTalk.get_noisy_pulses","title":"get_noisy_pulses","text":"<pre><code>get_noisy_pulses(\n    dims: list,\n    pulses: Optional[Pulse] = None,\n    systematic_noise: Optional[Pulse] = None,\n)\n</code></pre> <p>Return the input pulses list with noise added and the pulse independent noise in a dummy :class:<code>.Pulse</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>list</code> <p>The dimension of the components system, the default value is [3,3...,3] for qutrit system.</p> required <code>pulses</code> <code>list of :class:`.Pulse`</code> <p>The input pulses. The noise will be added to pulses in this list.</p> <code>None</code> <code>systematic_noise</code> <code>:class:`.Pulse`</code> <p>The dummy pulse with no ideal control element.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pulses</code> <code>list of :class:`.Pulse`</code> <p>Noisy pulses.</p> <code>systematic_noise</code> <code>:class:`.Pulse`</code> <p>The dummy pulse representing pulse-independent noise.</p>"},{"location":"reference/devices/sarimner/processor/","title":"processor","text":""},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor","title":"chalmers_qubit.devices.sarimner.processor","text":"<p>Classes:</p> Name Description <code>SarimnerProcessor</code> <p>Initialize a new SarimnerProcessor instance with a quantum model, an optional compiler, and noise models.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor","title":"SarimnerProcessor","text":"<pre><code>SarimnerProcessor(\n    model: Model,\n    compiler: Optional[GateCompiler] = None,\n    noise: Optional[list] = None,\n)\n</code></pre> <p>               Bases: <code>Processor</code></p> <p>Initialize a new SarimnerProcessor instance with a quantum model, an optional compiler, and noise models.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The quantum model that defines the physical properties and capabilities of the processor.</p> required <code>compiler</code> <code>GateCompiler</code> <p>The compiler used to translate quantum gates into executable operations. If not provided, a default compiler specific to the model (SarimnerCompiler) is instantiated and used.</p> <code>None</code> <code>noise</code> <code>list</code> <p>A list of noise models to be added to the processor. Each element in the list should be compatible with the processor's noise handling methods.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model of the quantum processor, storing physical properties.</p> <code>_default_compiler</code> <code>GateCompiler</code> <p>Holds the compiler instance being used, either the provided one or a default SarimnerCompiler.</p> <code>native_gates</code> <code>None</code> <p>Initially set to None, to be configured with the gate set natively supported by the processor.</p> <code>spline_kind</code> <code>str</code> <p>Type of the coefficient interpolation.</p> <code>global_phase</code> <code>float</code> <p>The global phase of the quantum state managed by the processor, initialized to 0.</p> <p>Methods:</p> Name Description <code>add_control</code> <p>Add a control Hamiltonian to the model. The new control Hamiltonian</p> <code>add_drift</code> <p>Add the drift Hamiltonian to the model.</p> <code>add_noise</code> <p>Add a noise object to the processor.</p> <code>add_pulse</code> <p>Add a new pulse to the device.</p> <code>eliminate_auxillary_modes</code> <p>Eliminate the auxillary modes like the cavity modes in cqed.</p> <code>get_all_drift</code> <p>Get all the drift Hamiltonians.</p> <code>get_control</code> <p>Get the control Hamiltonian corresponding to the label.</p> <code>get_control_labels</code> <p>Get a list of all available control Hamiltonians.</p> <code>get_control_latex</code> <p>Get the latex string for each Hamiltonian.</p> <code>get_full_coeffs</code> <p>Return the full coefficients in a 2d matrix form.</p> <code>get_full_tlist</code> <p>Return the full tlist of the ideal pulses.</p> <code>get_noise</code> <p>Get a list of :obj:<code>.Noise</code> objects.</p> <code>get_noisy_pulses</code> <p>It takes the pulses defined in the <code>Processor</code> and</p> <code>get_qobjevo</code> <p>Create a :class:<code>qutip.QobjEvo</code> representation of the evolution.</p> <code>load_circuit</code> <p>The default routine of compilation.</p> <code>plot_pulses</code> <p>Plot the ideal pulse coefficients.</p> <code>read_coeff</code> <p>Read the control amplitudes matrix and time list</p> <code>remove_pulse</code> <p>Remove the control pulse with given indices.</p> <code>run</code> <p>Calculate the propagator of the evolution by matrix exponentiation.</p> <code>run_analytically</code> <p>Simulate the state evolution under the given <code>qutip.QubitCircuit</code></p> <code>run_propagator</code> <p>Parameters</p> <code>save_coeff</code> <p>Save a file with the control amplitudes in each timeslot.</p> <code>set_coeffs</code> <p>Clear all the existing pulses and</p> <code>set_tlist</code> <p>Set the <code>tlist</code> for all existing pulses. It assumes that</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.coeffs","title":"coeffs  <code>property</code> <code>writable</code>","text":"<pre><code>coeffs\n</code></pre> <p>A list of ideal control coefficients for all saved pulses. The order matches with :obj:<code>Processor.controls</code></p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.controls","title":"controls  <code>property</code>","text":"<pre><code>controls\n</code></pre> <p>A list of the ideal control Hamiltonians in all saved pulses. Note that control Hamiltonians with no pulse will not be included. The order matches with :obj:<code>Processor.coeffs</code></p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.dims","title":"dims  <code>property</code> <code>writable</code>","text":"<pre><code>dims\n</code></pre> <p>The dimension of each component system. :type: list</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.drift","title":"drift  <code>property</code>","text":"<pre><code>drift\n</code></pre> <p>The drift Hamiltonian in the form <code>[(qobj, targets), ...]</code> :type: list</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.noise","title":"noise  <code>property</code>","text":"<pre><code>noise\n</code></pre> <p>.coverage</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.num_qubits","title":"num_qubits  <code>property</code> <code>writable</code>","text":"<pre><code>num_qubits\n</code></pre> <p>Number of qubits (or subsystems). For backward compatibility. :type: int</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.params","title":"params  <code>property</code>","text":"<pre><code>params\n</code></pre> <p>Hardware parameters. :type: dict</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.pulse_mode","title":"pulse_mode  <code>property</code> <code>writable</code>","text":"<pre><code>pulse_mode\n</code></pre> <p>If the given pulse is going to be interpreted as \"continuous\" or \"discrete\".</p> <p>:type: str</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.t1","title":"t1  <code>property</code> <code>writable</code>","text":"<pre><code>t1\n</code></pre> <p>Characterize the total amplitude damping of each qubit. :type: float or list</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.t2","title":"t2  <code>property</code> <code>writable</code>","text":"<pre><code>t2\n</code></pre> <p>Characterize the total dephasing for each qubit. :type: float or list</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.add_control","title":"add_control","text":"<pre><code>add_control(\n    qobj, targets=None, cyclic_permutation=False, label=None\n)\n</code></pre> <p>Add a control Hamiltonian to the model. The new control Hamiltonian is saved in the :obj:<code>.Processor.model</code> attributes.</p> <p>Parameters:</p> Name Type Description Default <code>qobj</code> <code>:obj:`qutip.Qobj`</code> <p>The control Hamiltonian.</p> required <code>targets</code> <code>list</code> <p>The indices of the target qubits (or composite quantum systems).</p> <code>None</code> <code>cyclic_permutation</code> <code>bool</code> <p>If true, the Hamiltonian will be added for all qubits, e.g. if <code>targets=[0,1]</code>, and there are 2 qubits, the Hamiltonian will be added to the target qubits <code>[0,1]</code>, <code>[1,2]</code> and <code>[2,0]</code>.</p> <code>False</code> <code>label</code> <code>str</code> <p>The hashable label (name) of the control Hamiltonian. If <code>None</code>, it will be set to the current number of control Hamiltonians in the system.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import qutip\n&gt;&gt;&gt; from qutip_qip.device import Processor\n&gt;&gt;&gt; processor = Processor(1)\n&gt;&gt;&gt; processor.add_control(qutip.sigmax(), 0, label=\"sx\")\n&gt;&gt;&gt; processor.get_control_labels()\n['sx']\n&gt;&gt;&gt; processor.get_control(\"sx\")\n(Quantum object: dims=[[2], [2]], shape=(2, 2),\ntype='oper', dtype=CSR, isherm=True\nQobj data =\n[[0. 1.]\n[1. 0.]], [0])\n</code></pre>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.add_drift","title":"add_drift","text":"<pre><code>add_drift(qobj, targets=None, cyclic_permutation=False)\n</code></pre> <p>Add the drift Hamiltonian to the model. The drift Hamiltonians are intrinsic of the quantum system and cannot be controlled by an external field.</p> <p>Parameters:</p> Name Type Description Default <code>qobj</code> <code>:class:`qutip.Qobj`</code> <p>The drift Hamiltonian.</p> required <code>targets</code> <code>list</code> <p>The indices of the target qubits (or subquantum system of other dimensions).</p> <code>None</code> <code>cyclic_permutation</code> <code>bool</code> <p>If true, the Hamiltonian will be added for all qubits, e.g. if <code>targets=[0,1]</code>, and there are 2 qubits, The Hamiltonian will be added to the target qubits <code>[0,1]</code>, <code>[1,2]</code> and <code>[2,0]</code>.</p> <code>False</code>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.add_noise","title":"add_noise","text":"<pre><code>add_noise(noise)\n</code></pre> <p>Add a noise object to the processor.</p> <p>Parameters:</p> Name Type Description Default <code>noise</code> <code>:class:`.Noise`</code> <p>The noise object defined outside the processor.</p> required"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.add_pulse","title":"add_pulse","text":"<pre><code>add_pulse(pulse)\n</code></pre> <p>Add a new pulse to the device.</p> <p>Parameters:</p> Name Type Description Default <code>pulse</code> <code>:class:`.Pulse`</code> <p><code>Pulse</code> object to be added.</p> required"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.eliminate_auxillary_modes","title":"eliminate_auxillary_modes","text":"<pre><code>eliminate_auxillary_modes(U)\n</code></pre> <p>Eliminate the auxillary modes like the cavity modes in cqed. (Defined in subclasses)</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_all_drift","title":"get_all_drift","text":"<pre><code>get_all_drift()\n</code></pre> <p>Get all the drift Hamiltonians.</p> <p>Returns:</p> Name Type Description <code>drift_hamiltonian_list</code> <code>list</code> <p>A list of drift Hamiltonians in the form of <code>[(qobj, targets), ...]</code>.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_control","title":"get_control","text":"<pre><code>get_control(label)\n</code></pre> <p>Get the control Hamiltonian corresponding to the label.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <p>A label that identifies the Hamiltonian.</p> required <p>Returns:</p> Name Type Description <code>control_hamiltonian</code> <code>tuple</code> <p>The control Hamiltonian in the form of <code>(qobj, targets)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from qutip_qip.device import LinearSpinChain\n&gt;&gt;&gt; processor = LinearSpinChain(1)\n&gt;&gt;&gt; processor.get_control_labels()\n['sx0', 'sz0']\n&gt;&gt;&gt; processor.get_control('sz0')\n(Quantum object: dims=[[2], [2]], shape=(2, 2),\ntype='oper', dtype=CSR, isherm=True\nQobj data =\n[[ 6.28319  0.     ]\n [ 0.      -6.28319]], 0)\n</code></pre>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_control_labels","title":"get_control_labels","text":"<pre><code>get_control_labels()\n</code></pre> <p>Get a list of all available control Hamiltonians.</p> <p>Returns:</p> Name Type Description <code>label_list</code> <code>list</code> <p>A list of hashable objects each corresponds to an available control Hamiltonian.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_control_latex","title":"get_control_latex","text":"<pre><code>get_control_latex()\n</code></pre> <p>Get the latex string for each Hamiltonian. It is used in the method :meth:<code>.Processor.plot_pulses</code>. It is a list of dictionaries. In the plot, a different color will be used for each dictionary in the list.</p> <p>Returns:</p> Name Type Description <code>nested_latex_str</code> <code>list of dict</code> <p>E.g.: <code>[{\"sx\": \"\\sigma_z\"}, {\"sy\": \"\\sigma_y\"}]</code>.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_full_coeffs","title":"get_full_coeffs","text":"<pre><code>get_full_coeffs(full_tlist=None)\n</code></pre> <p>Return the full coefficients in a 2d matrix form. Each row corresponds to one pulse. If the <code>tlist</code> are different for different pulses, the length of each row will be the same as the <code>full_tlist</code> (see method <code>get_full_tlist</code>). Interpolation is used for adding the missing coefficients according to <code>spline_kind</code>.</p> <p>Returns:</p> Name Type Description <code>coeffs</code> <code>array-like 2d</code> <p>The coefficients for all ideal pulses.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_full_tlist","title":"get_full_tlist","text":"<pre><code>get_full_tlist(tol=1e-10)\n</code></pre> <p>Return the full tlist of the ideal pulses. If different pulses have different time steps, it will collect all the time steps in a sorted array.</p> <p>Returns:</p> Name Type Description <code>full_tlist</code> <code>array-like 1d</code> <p>The full time sequence for the ideal evolution.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_noise","title":"get_noise","text":"<pre><code>get_noise()\n</code></pre> <p>Get a list of :obj:<code>.Noise</code> objects.</p> <p>Returns:</p> Name Type Description <code>noise_list</code> <code>list</code> <p>A list of :obj:<code>.Noise</code>.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_noisy_pulses","title":"get_noisy_pulses","text":"<pre><code>get_noisy_pulses(device_noise=False, drift=False)\n</code></pre> <p>It takes the pulses defined in the <code>Processor</code> and adds noise according to <code>Processor.noise</code>. It does not modify the pulses saved in <code>Processor.pulses</code> but returns a new list. The length of the new list of noisy pulses might be longer because of drift Hamiltonian and device noise. They will be added to the end of the pulses list.</p> <p>Parameters:</p> Name Type Description Default <code>device_noise</code> <p>If true, include pulse independent noise such as single qubit Relaxation. Default is False.</p> <code>False</code> <code>drift</code> <p>If true, include drift Hamiltonians. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>noisy_pulses</code> <code>list of :class:`.Drift`</code> <p>A list of noisy pulses.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.get_qobjevo","title":"get_qobjevo","text":"<pre><code>get_qobjevo(args=None, noisy=False)\n</code></pre> <p>Create a :class:<code>qutip.QobjEvo</code> representation of the evolution. It calls the method :meth:<code>.Processor.get_noisy_pulses</code> and create the <code>QobjEvo</code> from it.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Arguments for :class:<code>qutip.QobjEvo</code></p> <code>None</code> <code>noisy</code> <p>If noise are included. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>qobjevo</code> <code>:class:`qutip.QobjEvo`</code> <p>The :class:<code>qutip.QobjEvo</code> representation of the unitary evolution.</p> <code>c_ops</code> <code>list of :class:`qutip.QobjEvo`</code> <p>A list of lindblad operators is also returned. if <code>noisy==False</code>, it is always an empty list.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.load_circuit","title":"load_circuit","text":"<pre><code>load_circuit(\n    qc: QubitCircuit,\n    schedule_mode: str = \"ASAP\",\n    compiler: Optional[GateCompiler] = None,\n)\n</code></pre> <p>The default routine of compilation. It first calls the :meth:<code>.transpile</code> to convert the circuit to a suitable format for the hardware model. Then it calls the compiler and save the compiled pulses.</p> <p>Parameters:</p> Name Type Description Default <code>qc</code> <code>:class:`.QubitCircuit`</code> <p>Takes the quantum circuit to be implemented.</p> required <code>schedule_mode</code> <code>str</code> <p>\"ASAP\" or \"ALAP\" or None.</p> <code>'ASAP'</code> <code>compiler</code> <code>Optional[GateCompiler]</code> <p>The used compiler.</p> <code>None</code> <p>Returns:</p> Type Description <code>tlist, coeffs: dict of 1D NumPy array</code> <p>A dictionary of pulse label and the time sequence and compiled pulse coefficients.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.plot_pulses","title":"plot_pulses","text":"<pre><code>plot_pulses(\n    title=None,\n    figsize=(12, 6),\n    dpi=None,\n    show_axis=False,\n    rescale_pulse_coeffs=True,\n    num_steps=1000,\n    pulse_labels=None,\n    use_control_latex=True,\n)\n</code></pre> <p>Plot the ideal pulse coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <p>Title for the plot.</p> <code>None</code> <code>figsize</code> <p>The size of the figure.</p> <code>(12, 6)</code> <code>dpi</code> <p>The dpi of the figure.</p> <code>None</code> <code>show_axis</code> <p>If the axis are shown.</p> <code>False</code> <code>rescale_pulse_coeffs</code> <p>Rescale the hight of each pulses.</p> <code>True</code> <code>num_steps</code> <p>Number of time steps in the plot.</p> <code>1000</code> <code>pulse_labels</code> <p>A map between pulse labels and the labels shown in the y axis. E.g. <code>[{\"sx\": \"sigmax\"}]</code>. Pulses in each dictionary will get a different color. If not given and <code>use_control_latex==False</code>, the string label defined in each :obj:<code>.Pulse</code> is used.</p> <code>None</code> <code>use_control_latex</code> <p>Use labels defined in <code>Processor.model.get_control_latex</code>.</p> <code>True</code> <code>pulse_labels</code> <p>A map between pulse labels and the labels shown on the y axis. E.g. <code>[\"sx\", \"sigmax\"]</code>. If not given and <code>use_control_latex==False</code>, the string label defined in each :obj:<code>.Pulse</code> is used.</p> <code>None</code> <code>use_control_latex</code> <p>Use labels defined in <code>Processor.model.get_control_latex</code>.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The <code>Figure</code> object for the plot.</p> <code>axis</code> <code>list of ``matplotlib.axes._subplots.AxesSubplot``</code> <p>The axes for the plot.</p> Notes <p>:meth:.Processor.plot_pulses` only works for array_like coefficients.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.read_coeff","title":"read_coeff","text":"<pre><code>read_coeff(file_name, inctime=True)\n</code></pre> <p>Read the control amplitudes matrix and time list saved in the file by <code>save_amp</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <p>Name of the file.</p> required <code>inctime</code> <p>True if the time list in included in the first column.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>tlist</code> <code>array_like</code> <p>The time list read from the file.</p> <code>coeffs</code> <code>array_like</code> <p>The pulse matrix read from the file.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.remove_pulse","title":"remove_pulse","text":"<pre><code>remove_pulse(indices=None, label=None)\n</code></pre> <p>Remove the control pulse with given indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <p>The indices of the control Hamiltonians to be removed.</p> <code>None</code> <code>label</code> <p>The label of the pulse</p> <code>None</code>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.run","title":"run","text":"<pre><code>run(qc=None)\n</code></pre> <p>Calculate the propagator of the evolution by matrix exponentiation. This method won't include noise or collpase.</p> <p>Parameters:</p> Name Type Description Default <code>qc</code> <code>:class:`.QubitCircuit`</code> <p>Takes the quantum circuit to be implemented. If not given, use the quantum circuit saved in the processor by <code>load_circuit</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>U_list</code> <code>list</code> <p>The propagator matrix obtained from the physical implementation.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.run_analytically","title":"run_analytically","text":"<pre><code>run_analytically(init_state=None, qc=None)\n</code></pre> <p>Simulate the state evolution under the given <code>qutip.QubitCircuit</code> with matrice exponentiation. It will calculate the propagator with matrix exponentiation and return a list of :class:<code>qutip.Qobj</code>. This method won't include noise or collpase.</p> <p>Parameters:</p> Name Type Description Default <code>qc</code> <code>:class:`.QubitCircuit`</code> <p>Takes the quantum circuit to be implemented. If not given, use the quantum circuit saved in the processor by <code>load_circuit</code>.</p> <code>None</code> <code>init_state</code> <code>:class:`qutip.Qobj`</code> <p>The initial state of the qubits in the register.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>U_list</code> <code>list</code> <p>A list of propagators obtained for the physical implementation.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.run_propagator","title":"run_propagator","text":"<pre><code>run_propagator(\n    qc: Optional[QubitCircuit] = None,\n    noisy: bool = False,\n    **kwargs\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>qc</code> <code>Optional[QubitCircuit]</code> <p>A quantum circuit. If given, it first calls the <code>load_circuit</code> and then calculate the evolution.</p> <code>None</code> <code>noisy</code> <code>bool</code> <p>If noise are included. Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Keyword arguments for the qutip solver.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>prop</code> <code>list of Qobj or Qobj</code> <p>Returns the propagator(s) calculated at times t.</p>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.save_coeff","title":"save_coeff","text":"<pre><code>save_coeff(file_name, inctime=True)\n</code></pre> <p>Save a file with the control amplitudes in each timeslot.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <p>Name of the file.</p> required <code>inctime</code> <p>True if the time list should be included in the first column.</p> <code>True</code>"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.set_coeffs","title":"set_coeffs","text":"<pre><code>set_coeffs(coeffs)\n</code></pre> <p>Clear all the existing pulses and reset the coefficients for the control Hamiltonians.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <ul> <li>If it is a dict, it should be a map of   the label of control Hamiltonians and the   corresponding coefficients.   Use :obj:<code>.Processor.get_control_labels()</code> to see the   available Hamiltonians.</li> <li>If it is a list of arrays or a 2D NumPy array,   it is treated same to <code>dict</code>, only that   the pulse label is assumed to be integers from 0   to <code>len(coeffs)-1</code>.</li> </ul> required"},{"location":"reference/devices/sarimner/processor/#chalmers_qubit.devices.sarimner.processor.SarimnerProcessor.set_tlist","title":"set_tlist","text":"<pre><code>set_tlist(tlist)\n</code></pre> <p>Set the <code>tlist</code> for all existing pulses. It assumes that pulses all already added to the processor. To add pulses automatically, first use :obj:<code>Processor.set_coeffs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tlist</code> <p>If it is a dict, it should be a map between pulse label and the time sequences. If it is a list of arrays or a 2D NumPy array, each array will be associated to a pulse, following the order in the pulse list.</p> required"},{"location":"reference/utils/gates/","title":"gates","text":""},{"location":"reference/utils/gates/#chalmers_qubit.utils.gates","title":"chalmers_qubit.utils.gates","text":"<p>Functions:</p> Name Description <code>cczs</code> <p>Unitary of the cczs-gate</p>"},{"location":"reference/utils/gates/#chalmers_qubit.utils.gates.cczs","title":"cczs","text":"<pre><code>cczs(args: tuple) -&gt; Qobj\n</code></pre> <p>Unitary of the cczs-gate</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>tuple</code> <p>Input angles for the gate.</p> required <p>Returns:</p> Name Type Description <code>U</code> <code>Qobj</code> <p>The unitary for the cczs-gate.</p>"},{"location":"reference/utils/operations/","title":"operations","text":""},{"location":"reference/utils/operations/#chalmers_qubit.utils.operations","title":"chalmers_qubit.utils.operations","text":"<p>Functions:</p> Name Description <code>project_on_qubit</code> <p>Project a given quantum object (density matrix or state vector) onto the computational basis of qubits.</p>"},{"location":"reference/utils/operations/#chalmers_qubit.utils.operations.project_on_qubit","title":"project_on_qubit","text":"<pre><code>project_on_qubit(rho: Qobj) -&gt; Qobj\n</code></pre> <p>Project a given quantum object (density matrix or state vector) onto the computational basis of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>Qobj</code> <p>The input quantum object, either a density matrix ('oper' type) or a state vector.</p> required <p>Returns:</p> Name Type Description <code>qubit_state</code> <code>Qobj</code> <p>The projected quantum object onto the computational basis (0 and 1 states) of qubits.</p>"},{"location":"reference/utils/transformation/","title":"transformation","text":""},{"location":"reference/utils/transformation/#chalmers_qubit.utils.transformation","title":"chalmers_qubit.utils.transformation","text":"<p>Functions:</p> Name Description <code>pauli_basis</code> <p>Generate n-qubit Pauli basis using Kronecker product.</p> <code>unitary_to_ptm</code> <p>Convert a unitary Qobj to its Pauli Transfer Matrix (PTM).</p>"},{"location":"reference/utils/transformation/#chalmers_qubit.utils.transformation.pauli_basis","title":"pauli_basis","text":"<pre><code>pauli_basis(n_qubits: int) -&gt; list\n</code></pre> <p>Generate n-qubit Pauli basis using Kronecker product.</p>"},{"location":"reference/utils/transformation/#chalmers_qubit.utils.transformation.unitary_to_ptm","title":"unitary_to_ptm","text":"<pre><code>unitary_to_ptm(U: Qobj) -&gt; ndarray\n</code></pre> <p>Convert a unitary Qobj to its Pauli Transfer Matrix (PTM).</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/","title":"clifford_group","text":""},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group","title":"chalmers_qubit.utils.randomized_benchmarking.clifford_group","text":"<p>Classes:</p> Name Description <code>Clifford</code> <p>Base class for Clifford operations.</p> <code>SingleQubitClifford</code> <p>Single Qubit Clifford gate class.</p> <code>TwoQubitClifford</code> <p>Two Qubit Clifford gate class.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.Clifford","title":"Clifford","text":"<pre><code>Clifford(idx: int)\n</code></pre> <p>Base class for Clifford operations.</p> <p>Abstract base class for all Clifford operations.</p> <p>Attributes:</p> Name Type Description <code>idx</code> <code>int</code> <p>Index of the Clifford operation.</p> <code>GROUP_SIZE</code> <code>ClassVar[int]</code> <p>Size of the Clifford group.</p> <code>CLIFFORD_HASH_TABLE</code> <code>ClassVar[Dict[int, int]]</code> <p>Hash table for fast lookup of Clifford indices.</p> <p>Initialize the Clifford object with a given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the Clifford operation.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the index is not valid (0 &lt;= idx &lt; GROUP_SIZE).</p> <p>Methods:</p> Name Description <code>find_clifford_index</code> <p>Find the index of a Clifford matrix using hash lookup.</p> <code>get_inverse</code> <p>Get the inverse of this Clifford operation.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.Clifford.gate_decomposition","title":"gate_decomposition  <code>property</code>","text":"<pre><code>gate_decomposition: List[Tuple[List[str], str]]\n</code></pre> <p>Returns the gate decomposition of the Clifford gate.</p> <p>Returns:</p> Type Description <code>list of tuple</code> <p>Gate decomposition as a list of tuples (gate_name, qubit_identifier).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented in subclass.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.Clifford.pauli_transfer_matrix","title":"pauli_transfer_matrix  <code>property</code>","text":"<pre><code>pauli_transfer_matrix: ndarray\n</code></pre> <p>Returns the Pauli transfer matrix of the Clifford operation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The Pauli transfer matrix.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented in subclass.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.Clifford.find_clifford_index","title":"find_clifford_index  <code>classmethod</code>","text":"<pre><code>find_clifford_index(matrix: ndarray) -&gt; int\n</code></pre> <p>Find the index of a Clifford matrix using hash lookup.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>The Pauli transfer matrix.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the Clifford operation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Clifford index is not found.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.Clifford.get_inverse","title":"get_inverse","text":"<pre><code>get_inverse() -&gt; Clifford\n</code></pre> <p>Get the inverse of this Clifford operation.</p> <p>Returns:</p> Type Description <code>Clifford</code> <p>The inverse operation.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.SingleQubitClifford","title":"SingleQubitClifford","text":"<pre><code>SingleQubitClifford(idx: int)\n</code></pre> <p>               Bases: <code>Clifford</code></p> <p>Single Qubit Clifford gate class.</p> <p>The decomposition of the single qubit clifford group follows Epstein et al. Phys. Rev. A 89, 062321 (2014).</p> <p>Attributes:</p> Name Type Description <code>CLIFFORD_HASH_TABLE</code> <code>dict</code> <p>Hash table for fast lookup.</p> <code>GROUP_SIZE</code> <code>int</code> <p>Size of the single qubit Clifford group.</p> <p>Initialize the Clifford object with a given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the Clifford operation.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the index is not valid (0 &lt;= idx &lt; GROUP_SIZE).</p> <p>Methods:</p> Name Description <code>find_clifford_index</code> <p>Find the index of a Clifford matrix using hash lookup.</p> <code>get_inverse</code> <p>Get the inverse of this Clifford operation.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.SingleQubitClifford.gate_decomposition","title":"gate_decomposition  <code>property</code>","text":"<pre><code>gate_decomposition: List[Tuple[List[str], str]]\n</code></pre> <p>Returns the gate decomposition of the single qubit Clifford group according to the decomposition by Epstein et al.</p> <p>Returns:</p> Type Description <code>list of tuple</code> <p>Each tuple contains (gate_name, qubit_identifier).</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.SingleQubitClifford.pauli_transfer_matrix","title":"pauli_transfer_matrix  <code>property</code>","text":"<pre><code>pauli_transfer_matrix: ndarray\n</code></pre> <p>Returns the Pauli transfer matrix of the single qubit Clifford operation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Pauli transfer matrix.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.SingleQubitClifford.find_clifford_index","title":"find_clifford_index  <code>classmethod</code>","text":"<pre><code>find_clifford_index(matrix: ndarray) -&gt; int\n</code></pre> <p>Find the index of a Clifford matrix using hash lookup.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>The Pauli transfer matrix.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the Clifford operation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Clifford index is not found.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.SingleQubitClifford.get_inverse","title":"get_inverse","text":"<pre><code>get_inverse() -&gt; Clifford\n</code></pre> <p>Get the inverse of this Clifford operation.</p> <p>Returns:</p> Type Description <code>Clifford</code> <p>The inverse operation.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford","title":"TwoQubitClifford","text":"<pre><code>TwoQubitClifford(idx: int)\n</code></pre> <p>               Bases: <code>Clifford</code></p> <p>Two Qubit Clifford gate class.</p> <p>The Clifford decomposition closely follows: 1. Corcoles et al. Process verification ... Phys. Rev. A. 2013. 2. Barends et al. Superconducting quantum circuits ... Nature 2014.</p> <p>The two qubit Clifford group (C2) consists of 11520 two-qubit Cliffords, subdivided into four classes.</p> <p>Attributes:</p> Name Type Description <code>CLIFFORD_HASH_TABLE</code> <code>dict</code> <p>Hash table for fast lookup.</p> <code>_PTM_CACHE</code> <code>dict</code> <p>Cache for PTMs.</p> <code>_GATE_DECOMP_CACHE</code> <code>dict</code> <p>Cache for gate decompositions.</p> <code>GROUP_SIZE</code> <code>int</code> <p>Size of the two-qubit Clifford group.</p> <p>Initialize the Clifford object with a given index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the Clifford operation.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the index is not valid (0 &lt;= idx &lt; GROUP_SIZE).</p> <p>Methods:</p> Name Description <code>CNOT_like_PTM</code> <p>Returns the pauli transfer matrix for gates of the CNOT-like class.</p> <code>CNOT_like_gates</code> <p>Returns the gates for Cliffords of the CNOT-like class.</p> <code>SWAP_like_PTM</code> <p>Returns the pauli transfer matrix for gates of the SWAP-like class.</p> <code>SWAP_like_gates</code> <p>Returns the gates for Cliffords of the SWAP-like class.</p> <code>find_clifford_index</code> <p>Find the index of a Clifford matrix using hash lookup.</p> <code>get_inverse</code> <p>Get the inverse of this Clifford operation.</p> <code>iSWAP_like_PTM</code> <p>Returns the pauli transfer matrix for gates of the iSWAP-like class.</p> <code>iSWAP_like_gates</code> <p>Returns the gates for Cliffords of the iSWAP-like class.</p> <code>single_qubit_like_PTM</code> <p>Returns the pauli transfer matrix for gates of the single qubit like class.</p> <code>single_qubit_like_gates</code> <p>Returns the gates for Cliffords of the single qubit like class.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.gate_decomposition","title":"gate_decomposition  <code>property</code>","text":"<pre><code>gate_decomposition\n</code></pre> <p>Returns the gate decomposition of the two qubit Clifford group.</p> <p>Returns:</p> Type Description <code>list of tuple</code> <p>Gate decomposition as a list of tuples (gate_name, qubit_identifier).</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.pauli_transfer_matrix","title":"pauli_transfer_matrix  <code>property</code>","text":"<pre><code>pauli_transfer_matrix: ndarray\n</code></pre> <p>Returns the Pauli transfer matrix for the two-qubit Clifford operation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Pauli transfer matrix.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.CNOT_like_PTM","title":"CNOT_like_PTM  <code>classmethod</code>","text":"<pre><code>CNOT_like_PTM(idx: int) -&gt; ndarray\n</code></pre> <p>Returns the pauli transfer matrix for gates of the CNOT-like class.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index within the CNOT-like class.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Pauli transfer matrix.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.CNOT_like_gates","title":"CNOT_like_gates  <code>classmethod</code>","text":"<pre><code>CNOT_like_gates(idx: int)\n</code></pre> <p>Returns the gates for Cliffords of the CNOT-like class.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index within the CNOT-like class.</p> required <p>Returns:</p> Type Description <code>list of tuple</code> <p>Each tuple contains (gate_name, qubit_identifier).</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.SWAP_like_PTM","title":"SWAP_like_PTM  <code>classmethod</code>","text":"<pre><code>SWAP_like_PTM(idx: int) -&gt; ndarray\n</code></pre> <p>Returns the pauli transfer matrix for gates of the SWAP-like class.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index within the SWAP-like class.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Pauli transfer matrix.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.SWAP_like_gates","title":"SWAP_like_gates  <code>classmethod</code>","text":"<pre><code>SWAP_like_gates(idx: int)\n</code></pre> <p>Returns the gates for Cliffords of the SWAP-like class.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index within the SWAP-like class.</p> required <p>Returns:</p> Type Description <code>list of tuple</code> <p>Each tuple contains (gate_name, qubit_identifier).</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.find_clifford_index","title":"find_clifford_index  <code>classmethod</code>","text":"<pre><code>find_clifford_index(matrix: ndarray) -&gt; int\n</code></pre> <p>Find the index of a Clifford matrix using hash lookup.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>The Pauli transfer matrix.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the Clifford operation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Clifford index is not found.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.get_inverse","title":"get_inverse","text":"<pre><code>get_inverse() -&gt; Clifford\n</code></pre> <p>Get the inverse of this Clifford operation.</p> <p>Returns:</p> Type Description <code>Clifford</code> <p>The inverse operation.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.iSWAP_like_PTM","title":"iSWAP_like_PTM  <code>classmethod</code>","text":"<pre><code>iSWAP_like_PTM(idx: int) -&gt; ndarray\n</code></pre> <p>Returns the pauli transfer matrix for gates of the iSWAP-like class.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index within the iSWAP-like class.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Pauli transfer matrix.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.iSWAP_like_gates","title":"iSWAP_like_gates  <code>classmethod</code>","text":"<pre><code>iSWAP_like_gates(idx: int)\n</code></pre> <p>Returns the gates for Cliffords of the iSWAP-like class.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index within the iSWAP-like class.</p> required <p>Returns:</p> Type Description <code>list of tuple</code> <p>Each tuple contains (gate_name, qubit_identifier).</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.single_qubit_like_PTM","title":"single_qubit_like_PTM  <code>classmethod</code>","text":"<pre><code>single_qubit_like_PTM(idx: int) -&gt; ndarray\n</code></pre> <p>Returns the pauli transfer matrix for gates of the single qubit like class.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index within the single qubit like class.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Pauli transfer matrix.</p>"},{"location":"reference/utils/randomized_benchmarking/clifford_group/#chalmers_qubit.utils.randomized_benchmarking.clifford_group.TwoQubitClifford.single_qubit_like_gates","title":"single_qubit_like_gates  <code>classmethod</code>","text":"<pre><code>single_qubit_like_gates(idx: int) -&gt; List[Tuple[str, str]]\n</code></pre> <p>Returns the gates for Cliffords of the single qubit like class.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index within the single qubit like class.</p> required <p>Returns:</p> Type Description <code>list of tuple</code> <p>Each tuple contains (gate_name, qubit_identifier).</p>"},{"location":"reference/utils/randomized_benchmarking/pauli_transfer_matrices/","title":"pauli_transfer_matrices","text":""},{"location":"reference/utils/randomized_benchmarking/pauli_transfer_matrices/#chalmers_qubit.utils.randomized_benchmarking.pauli_transfer_matrices","title":"chalmers_qubit.utils.randomized_benchmarking.pauli_transfer_matrices","text":"<p>Functions:</p> Name Description <code>X_theta</code> <p>Return the Pauli Transfer Matrix (PTM) of a rotation of angle theta</p> <code>Y_theta</code> <p>Return the Pauli Transfer Matrix (PTM) of a rotation of angle theta</p>"},{"location":"reference/utils/randomized_benchmarking/pauli_transfer_matrices/#chalmers_qubit.utils.randomized_benchmarking.pauli_transfer_matrices.X_theta","title":"X_theta","text":"<pre><code>X_theta(\n    theta: float, unit: Literal[\"deg\", \"rad\"] = \"deg\"\n) -&gt; ndarray\n</code></pre> <p>Return the Pauli Transfer Matrix (PTM) of a rotation of angle theta around the X-axis.</p> <p>Args:     theta (float): Rotation angle.     unit (str): Unit of the angle, either \"deg\" for degrees or \"rad\" for radians.</p> <p>Returns:     np.ndarray: The 4x4 PTM matrix corresponding to the X rotation.</p>"},{"location":"reference/utils/randomized_benchmarking/pauli_transfer_matrices/#chalmers_qubit.utils.randomized_benchmarking.pauli_transfer_matrices.Y_theta","title":"Y_theta","text":"<pre><code>Y_theta(\n    theta: float, unit: Literal[\"deg\", \"rad\"] = \"deg\"\n) -&gt; ndarray\n</code></pre> <p>Return the Pauli Transfer Matrix (PTM) of a rotation of angle theta around the Y-axis.</p> <p>Args:     theta (float): Rotation angle.     unit (str): Unit of the angle, either \"deg\" for degrees or \"rad\" for radians.</p> <p>Returns:     np.ndarray: The 4x4 PTM matrix corresponding to the Y rotation.</p>"},{"location":"reference/utils/randomized_benchmarking/randomized_benchmarking/","title":"randomized_benchmarking","text":""},{"location":"reference/utils/randomized_benchmarking/randomized_benchmarking/#chalmers_qubit.utils.randomized_benchmarking.randomized_benchmarking","title":"chalmers_qubit.utils.randomized_benchmarking.randomized_benchmarking","text":"<p>Classes:</p> Name Description <code>RandomizedBenchmarking</code> <p>Implementation of Clifford-based Randomized Benchmarking (RB) for quantum gates.</p>"},{"location":"reference/utils/randomized_benchmarking/randomized_benchmarking/#chalmers_qubit.utils.randomized_benchmarking.randomized_benchmarking.RandomizedBenchmarking","title":"RandomizedBenchmarking","text":"<pre><code>RandomizedBenchmarking(clifford_group: Literal[1, 2] = 1)\n</code></pre> <p>Implementation of Clifford-based Randomized Benchmarking (RB) for quantum gates.</p> <p>This class supports standard and interleaved randomized benchmarking for one and  two-qubit Clifford groups. It generates random Clifford sequences and converts them  to quantum circuits with physical gates.</p> <p>Attributes:</p> Name Type Description <code>clifford_group</code> <code>int</code> <p>Specifies which Clifford group to use (1 for single-qubit, 2 for two-qubit).</p> <code>CliffordClass</code> <code>Type</code> <p>The class representing Clifford operations for the chosen group.</p> <p>Initialize the RandomizedBenchmarking class.</p> <p>Parameters:</p> Name Type Description Default <code>clifford_group</code> <code>Literal[1, 2]</code> <p>Specifies which Clifford group to use. 1 for single-qubit (24 elements), 2 for two-qubit (11,520 elements).</p> <code>1</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If an unsupported Clifford group is specified.</p> <p>Methods:</p> Name Description <code>randomized_benchmarking_circuit</code> <p>Generate a randomized benchmarking circuit from a sequence of Clifford indices.</p>"},{"location":"reference/utils/randomized_benchmarking/randomized_benchmarking/#chalmers_qubit.utils.randomized_benchmarking.randomized_benchmarking.RandomizedBenchmarking.randomized_benchmarking_circuit","title":"randomized_benchmarking_circuit","text":"<pre><code>randomized_benchmarking_circuit(\n    number_of_cliffords: int,\n    apply_inverse: bool = True,\n    interleaved_clifford_gate: Optional[\n        Union[Gate, QubitCircuit]\n    ] = None,\n    seed: Optional[int] = None,\n) -&gt; QubitCircuit\n</code></pre> <p>Generate a randomized benchmarking circuit from a sequence of Clifford indices.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_cliffords</code> <code>int</code> <p>Number of Cliffords in the sequence.</p> required <code>apply_inverse</code> <code>bool</code> <p>Whether to append the recovery Clifford that inverts the total sequence.</p> <code>True</code> <code>interleaved_clifford_gate</code> <code>Optional[Union[Gate, QubitCircuit]]</code> <p>Optional interleaved Clifford gate or circuit.</p> <code>None</code> <code>seed</code> <code>Optional[int]</code> <p>Optional seed for reproducibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>QubitCircuit</code> <p>The randomized benchmarking circuit.</p>"},{"location":"user_guide/noise/","title":"Noise","text":""},{"location":"user_guide/noise/#decoherence","title":"Decoherence","text":"<p>Decoherence refers to the loss of quantum information due to interactions with the environment. There are two main types of decoherence: longitudinal decoherence and transversal decoherence.</p>"},{"location":"user_guide/noise/#longitudinal-decoherence","title":"Longitudinal decoherence","text":"<p>The \\(T_1\\) relaxation time describes the decay of a qubit's excited state population. It is characterized by the collapse operator \\(\\sqrt{\\Gamma_1} \\hat a\\), where \\(\\hat a\\) is the annihilation operator and \\(\\Gamma_1 = 1/T_1\\) is the decay rate. This leads to an exponential decay of the population of first excited state proportional of \\(\\exp(-\\Gamma_1 t)\\).</p>"},{"location":"user_guide/noise/#transversal-decoherence","title":"Transversal decoherence","text":"<p>The \\(T_2\\) dephasing time describes the loss of phase coherence, meaning the information about the qubits' relative phase is lost. Here, it's important to note that \\(T_1\\) relaxation also contributes to dephasing with a rate proportional to \\(\\exp(-\\frac{t}{2T_1})\\).</p> <p>To make sure that the overall phase damping is \\(\\exp(-\\frac{t}{T_2})\\), we use the collapse operator \\(\\sqrt{\\frac{\\Gamma_\\varphi}{2}} 2 \\hat n = \\frac{1}{\\sqrt{2T_\\varphi}} 2 \\hat n\\), where \\(\\hat n\\) is the number operator and</p> \\[ \\Gamma_\\varphi \\equiv \\frac{1}{T_\\varphi} = \\frac{1}{T_2} - \\frac{1}{2T_1}. \\] <p>This equation also highlights why \\(T_2\\) is always lesss than or equal to twice \\(T_1\\) \\((T_2\\leq 2T_1)\\).</p>"},{"location":"user_guide/noise/#example","title":"Example","text":"<p>To simulate with \\(T_1\\) and \\(T_2\\) noise</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom qutip_qip.circuit import QubitCircuit\nfrom chalmers_qubit.devices.sarimner import (\n    SarimnerProcessor, SarimnerModel, SarimnerCompiler\n)\n\n# Qubit frequencies in (GHz)\ntransmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n}\n# Relaxation time in (ns)\ndecoherence_dict = {\n    0: {\"t1\": 60e3, \"t2\": 80e3},\n}\n\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n\n# Choose compiler\ncompiler = SarimnerCompiler(model=model)\n\n# Add noise\nnoise = [DecoherenceNoise(decoherence_dict=decoherence_dict)]\n\n# Create the processor with the given hardware parameters and noise\nsarimner = SarimnerProcessor(model=model, compiler=compiler, noise=noise)\n</code></pre>"},{"location":"user_guide/noise/#zz-crosstalk","title":"ZZ-Crosstalk","text":"<p>ZZ-crosstalk is a phenomenon in quantum computing, particularly relevant in systems with superconducting qubits, where the interaction between two or more qubits leads to unwanted phase shifts in the qubits that are not being directly operated upon. This effect arises due to the residual coupling between qubits, even when they are not intentionally interacting. The \"ZZ\" refers to the interaction type, denoting the direct coupling between the Z components of the qubit state.</p> <p>Mathematically, ZZ-crosstalk between two qubits is represented by a constant drift term of the form \\(\\zeta(\\hat n \\otimes \\hat n)\\), where \\(\\zeta\\) represents the strength of the crosstalk and \\(\\hat n\\) is the number operator.</p>"},{"location":"user_guide/noise/#example_1","title":"Example","text":"<p>To simulate with ZZ-crosstalk</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom qutip_qip.circuit import QubitCircuit\nfrom chalmers_qubit.devices.sarimner import (\n    SarimnerProcessor, SarimnerModel, SarimnerCompiler\n)\n\n# Qubit frequencies in (GHz)\ntransmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n    1: {\"frequency\": 5.4, \"anharmonicity\": -0.30},\n}\n# Cross-talk in (GHz)\ncross_talk_dict = {(0,1): 1e-3}\n\n# Create the processor with the given hardware parameters\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n\n# Choose compiler\ncompiler = SarimnerCompiler(model=model)\n\n# Add noise\nnoise = [ZZCrossTalk(cross_talk_dict=cross_talk_dict)]\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, compiler, noise=noise)\n</code></pre>"},{"location":"user_guide/noise/#example_2","title":"Example","text":"<p>For examples on how to use these noise models check out relaxation.ipynb.</p>"},{"location":"user_guide/quantum_gates/","title":"Quantum Gates","text":""},{"location":"user_guide/quantum_gates/#single-qubit-gates","title":"Single-qubit gates","text":""},{"location":"user_guide/quantum_gates/#rotational-x-and-y-gates","title":"Rotational X and Y-gates","text":"<p>On this page we are describing how a single-qubit gate that implements rotation around the \\(x\\)- or \\(y\\)-axis on the Bloch sphere can be performed.</p> <p>We consider a driven weakly anharmonic qubit whose Hamiltonian in lab frame can be written as</p> \\[ \\frac{H}{\\hbar} = \\omega_q a^\\dagger a+\\frac{\\alpha}{2} a^\\dagger a^\\dagger a a +E(t)a^\\dagger+E(t)a, \\] <p>where \\(\\omega_q\\equiv \\omega_q^{0\\rightarrow 1}\\) is the qubit frequency and \\(\\alpha = \\omega_q ^{1\\rightarrow 2}-\\omega_q^{0\\rightarrow 1}\\) is the anharmonicity. The driving and control is given by</p> \\[ E(t)= \\begin{cases}     \\Omega^x(t)\\cos(\\omega_d t)+\\Omega^y(t)\\sin(\\omega_d t), &amp; 0&lt;t&lt;t_g, \\\\     0, &amp; \\text{otherwise}. \\end{cases} \\] <p>Here \\(\\Omega^x(t)\\) and \\(\\Omega^y(t)\\) are two independent quadrature controls, \\(t_g\\) is the total gate-time, and \\(\\omega_d\\) is the drive frequency. Next we move into the rotating frame of the drive by performing the following unitary transformation \\(U(t)=e^{i\\omega_r t a^\\dagger a}\\), where \\(\\omega_r\\) is the rotating frame frequency. The Hamiltonian in the rotating frame after having performed the rotating wave approximation reads</p> \\[ \\frac{H^R}{\\hbar} = \\Delta a^\\dagger a + \\frac{\\alpha}{2} a^{\\dagger 2}a^2 + (\\frac{\\Omega^x(t)}{2}\\cos([\\omega_r-\\omega_d]t)-\\frac{\\Omega^y(t)}{2}\\sin([\\omega_r-\\omega_d]t))(a^\\dagger + a) + (\\frac{\\Omega^x(t)}{2}\\sin([\\omega_r-\\omega_d]t)+\\frac{\\Omega^y(t)}{2}\\cos([\\omega_r-\\omega_d]t))(ia^\\dagger - ia), \\] <p>where \\(\\Delta \\equiv \\omega_q - \\omega_r\\) is the qubit detuning.</p> <p>As a concrete example, assume that we apply a pulse at the qubit frequency \\(\\omega_d=\\omega_q\\), and choose the rotating frame of the drive \\(\\omega_r=\\omega_d\\). Then,</p> \\[ \\frac{H^R}{\\hbar} = \\frac{\\alpha}{2} a^{\\dagger 2}a^2 + \\frac{\\Omega^x(t)}{2}(a^\\dagger + a) + \\frac{\\Omega^y(t)}{2}(ia^\\dagger - ia). \\] <p>If we treat the Hamiltonian as an effective two level system (ignoring the anharmonic term) and make the replacement \\((a^\\dagger + a)\\rightarrow \\sigma_x\\) and \\((ia^\\dagger-ia)\\rightarrow \\sigma_y\\), we obtain</p> \\[ \\frac{H^R}{\\hbar} = \\frac{\\Omega^x(t)}{2}\\sigma_x + \\frac{\\Omega^y(t)}{2}\\sigma_y, \\] <p>showing that an in-phase pulse (i.e. the \\(\\Omega^x(t)\\) quadrature component) corresponds to a rotation around the \\(x\\)-axis while the out-of-phase pulse (i.e. the \\(\\Omega^y(t)\\) quadrature component), corresponds to rotations about the \\(y\\)-axis. As a concrete example of an in-phase pulse, writing out the unitary evolution operator yields,</p> \\[ U^R(t)=\\exp([-\\frac{i}{2}\\int_0^t\\Omega^x(t')\\mathrm{d}t']\\sigma_x). \\] <p>By defining the angle</p> \\[ \\Theta(t)=\\int_0^t \\Omega^x(t')\\mathrm{d}t', \\] <p>which is the angle a state is rotated given a waveform envelope \\(\\Omega^x(t)\\). This means that to implement a \\(\\pi\\)-pulse on the \\(x\\)-axis one would solve \\(\\Theta(t)=\\pi\\) and output the signal in-phase with the qubit drive. Typically \\(\\Omega^x(t)\\) is choosen as a gaussian pulse</p> \\[ \\Omega^x(t) = B e^{-\\frac{(t-t_g/2)^2}{2\\sigma^2}} \\] <p>In this simple example we assumed that we could ignore the higher levels of the qubit. In general leakage errors which take the qubit out of the computational subspace as well as phase errors can occur. To combat theses errors the so-called DRAG<sup>1</sup> procedure (Derivative Reduction by Adiabatic Gate) is used. In doing so we apply an extra signal in the out-of-phase component, such that</p> \\[ \\Omega^x(t) = B e^{-\\frac{(t-t_g/2)^2}{2\\sigma^2}},\\quad \\Omega^y(t) = q\\sigma\\frac{d\\Omega^x(t)}{dt} \\] <p>where \\(q\\) is a scale parameter that needs to be optimized with respect to a \\(\\pi/2\\)-pulse. Interchanging \\(\\Omega^x(t)\\) and \\(\\Omega^y(t)\\) in the equation above corresponds to DRAG pulsing the \\(\\Omega^y(t)\\) component. The amplitude \\(B\\) is fixed such that</p> \\[ \\Big|\\int_{0}^{t}[\\Omega^x(t')+i\\Omega^y(t')]\\mathrm{d}t'\\Big|=\\pi. \\] <p>for a \\(\\pi\\)-pulse with DRAG.</p>"},{"location":"user_guide/quantum_gates/#example-x-rotation-with-drag","title":"Example: X-rotation with DRAG","text":"<p>The following example shows how an \\(R_X(\\pi/2)\\)-gate is implemented on the <code>Sarimner</code> using drag.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom qutip_qip.circuit import QubitCircuit\nfrom chalmers_qubit.devices.sarimner import (\n    SarimnerProcessor, SarimnerModel, SarimnerCompiler\n)\n\n# Create circuit with a single RX-gate\ncircuit = QubitCircuit(1)\ncircuit.add_gate(\"RX\", targets=0, arg_value=np.pi/2)\n\n# Qubit frequencies in (GHz)\ntransmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n}\n\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n\n# Choose compiler\ncompiler = SarimnerCompiler(model=model)\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, compiler=compiler)\n\n# Load circuit\ntlist, coeffs = sarimner.load_circuit(circuit)\n\n# Plot pulses\nfig, axis = sarimner.plot_pulses(show_axis=True)\nplt.xlabel(\"Time (ns)\")\n</code></pre> <p></p> <p>Currently only Gaussian pulses are available for single-qubit gates, but cosine pulses are soon going to be implemented as well. To configure the Gaussian pulse, such as, amplitude, standard deviation, and gate-time, the following options can be suppied to the <code>SarimnerCompiler</code></p> <pre><code># Options for compiler\noptions = {\n    \"dt\": 0.1, # time-step of simulator in (ns)\n    \"single_qubit_gate\": { # the following are the default values\n        \"type\": \"gaussian\",\n        \"gate_time\": 50, # in (ns)\n        \"amplitude\": 0.12533148558448476,\n        \"std\": 5,  # in (ns)\n    },\n}\ncompiler = SarimnerCompiler(options=options)\n</code></pre>"},{"location":"user_guide/quantum_gates/#virtual-z-gate","title":"Virtual Z-gate","text":"<p>To implement the \\(R_Z(\\theta)\\)-gate, we include a phase \\(\\phi\\) to our drive</p> \\[ E(t) = \\begin{cases}     \\Omega^x(t)\\cos(\\omega_d t + \\phi)+\\Omega^y(t)\\sin(\\omega_d t + \\phi),&amp; 0&lt;t&lt;t_g, \\\\ 0, &amp; \\text{otherwise}. \\end{cases} \\] <p>Upon initialization, all qubit drives are initialized with a phase of \\(\\phi=0\\). Now, when a \\(R_Z(\\theta)\\)-gate is performed we simply update the phase of the corresponding qubit drive, such that \\(\\phi\\) shifts to \\(-\\theta\\). The minus sign here signifies that we do a rotation of the Bloch sphere rather than the state itself.</p> <p>Note: If a \\(R_Z(\\phi)\\)-gate is performed at the end of a quantum circuit, this gate will not have any effect on the quantum state.</p>"},{"location":"user_guide/quantum_gates/#example-hadamard-gate-decomposition-and-phase-correction","title":"Example: Hadamard Gate Decomposition and Phase Correction","text":"<p>The Hadamard gate (\\(H\\)) can be decomposed into a sequence of rotations: a \\(\\pi\\) rotation around the Z-axis followed by a \\(\\pi/2\\) rotation around the Y-axis. Mathematically, this is expressed as \\(H = iR_Y(\\pi/2)R_Z(\\pi)\\), where \\(i\\) is a global phase factor. Notably, this decomposition allows for implementing the Hadamard gate using only one physical gate.</p> <p>The following example simulates the Hadamard gate applied to the initial state \\(\\ket{0}\\).</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom qutip_qip.circuit import QubitCircuit\nfrom chalmers_qubit.devices.sarimner import (\n    SarimnerProcessor, SarimnerModel, SarimnerCompiler\n)\n\n# Create circuit with a single Hadamard-gate\ncircuit = QubitCircuit(1)\ncircuit.add_gate(\"H\", targets=0)\n\n# Qubit frequencies in (GHz)\ntransmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n}\n\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n\n# Choose compiler\ncompiler = SarimnerCompiler(model=model)\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, compiler=compiler)\n\n# Load circuit\ntlist, coeffs = sarimner.load_circuit(circuit)\n\n# Prepare initial state and run simulation\ninit_state = basis(3, 0)\nresult = sarimner.run_state(init_state)\nfinal_state = project_on_qubit(result.states[-1])\nprint(final_state)\n</code></pre> <p>While the intended operation is to transform \\(\\ket{0}\\) to the equal superposition state \\(\\ket{+}=(\\ket{0}+\\ket{1})/\\sqrt{2}\\), the simulation initially yields \\(\\ket{-}=(\\ket{0}-\\ket{1})/\\sqrt{2}\\). This difference arises because the \\(R_Z(\\pi)\\) gate performs a virtual rotation on the Bloch sphere. This is illustrated in the figure below, where figure (a) shows the initial state \\(\\ket{0}\\). (b) shows the virtually rotated Bloch sphere after the \\(R_Z(\\pi)\\)-gate, and (c) shows the final-state after the \\(R_Y(\\pi/2)\\)-rotation with the green arrow showing the direction of the drive.</p> <p></p> <p>The state is however unaffected by this virtual rotation of the Bloch sphere. Therefore, to obtain the correct phase factor of our state, we can use the <code>phase</code> attribute of the <code>compiler</code> class. This attribute holds the phase corrections for all qubits, i.e. how much we have rotated the Bloch sphere for each qubit. As such, applying a rotation gate (<code>rz</code>) with this phase to the final state will yeild a state with the correct phase.</p> <pre><code>from qutip_qip.operations.gates import rz\n\n# Extract phase correction from the compiler\nphase = compiler.phase\n# Apply phase correction to the final state\nphase_corrected_state = rz(phase[0]) * final_state\nprint(phase_corrected_state)\n</code></pre>"},{"location":"user_guide/quantum_gates/#multi-qubit-gates","title":"Multi-qubit gates","text":""},{"location":"user_guide/quantum_gates/#iswap-gate","title":"ISWAP-gate","text":"<p>The ISWAP-gate between two qubits are performed using a time-dependent coupling term of the form</p> \\[ \\frac{H_\\mathrm{coupling}(t)}{\\hbar} = g(t)(\\ket{10}\\bra{01}+\\ket{01}\\bra{10}), \\] <p>where the time-dependent coupling term \\(g(t)\\) is given by a step-function with amplitude \\(g\\) and sinusodial rise-and-fall time. The gate time for the ISWAP-gate is dependent on the coupling strength \\(g\\) as:</p> \\[ t_\\mathrm{gate} = \\frac{1}{4g} \\]"},{"location":"user_guide/quantum_gates/#example","title":"Example","text":"<p>To following example shows the execution of a ISWAP-gate.</p> <pre><code># Define a circuit and run the simulation\nnum_qubits = 2\ncircuit = QubitCircuit(num_qubits)\ncircuit.add_gate(\"ISWAP\", controls=0, targets=1)\n\n# Qubit frequencies in (GHz)\ntransmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n    1: {\"frequency\": 5.4, \"anharmonicity\": -0.30},\n}\n# Time of ISWAP-gate in (ns)\nt = 100\n# Calculate corresponding coupling strength\ng = 1 / (4 * t)\ncoupling_dict = {\n    (0, 1): g,\n}\n\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict, coupling_dict=coupling_dict)\n\n# Choose compiler\ncompiler = SarimnerCompiler(model=model)\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, compiler=compiler)\n\ntlist, coeffs = sarimner.load_circuit(circuit)\n\nsarimner.plot_pulses(show_axis=True);\n</code></pre> <p></p> <p>To see that the ISWAP-gate is implemented correctly we will now simulate the circuit using the master equation simulation and look at the expectation values of the \\(|01\\rangle\\) and \\(|10\\rangle\\) states.</p> <pre><code>ket01 = tensor(basis(3,0), basis(3,1))\nket10 = tensor(basis(3,1), basis(3,0))\n# List of operators we wanna compute the expectation value for during the simulation\ne_ops = [ket2dm(ket01), ket2dm(ket10)]\nresult = sarimner.run_state(ket01, e_ops=e_ops)\n</code></pre> <p>and then plot the results</p> <pre><code>import matplotlib.pyplot as plt\nplt.plot(result.times, result.expect[0], label=\"01\")\nplt.plot(result.times, result.expect[1], label=\"10\")\nplt.xlabel('Time (ns)')\nplt.ylabel('Population')\nplt.legend()\n</code></pre> <p></p> <p>The pulse \\(g(t)\\) can moreover be configured to include a rise-and-fall time as well as a buffer time. To include this we can supply options to the <code>SarimnerCompiler</code></p> <pre><code># Define a circuit and run the simulation\nnum_qubits = 2\ncircuit = QubitCircuit(num_qubits)\ncircuit.add_gate(\"ISWAP\", controls=0, targets=1)\n\n# Qubit frequencies in (GHz)\ntransmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n    1: {\"frequency\": 5.4, \"anharmonicity\": -0.30},\n}\n# Time of ISWAP-gate in (ns)\nt = 100\n# Calculate corresponding coupling strength\ng = 1 / (4 * t)\ncoupling_dict = {\n    (0, 1): g,\n}\n\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict, coupling_dict=coupling_dict)\n\n# Options for compiler\noptions = {\n    \"two_qubit_gate\": {\n        \"buffer_time\": 5, # in (ns)\n        \"rise_fall_time\": 10, # in (ns)\n    },\n}\n\n# Choose compiler\ncompiler = SarimnerCompiler(model=model, options=options)\n\n# Create the processor with the given hardware parameters\nsarimner = SarimnerProcessor(model=model, compiler=compiler)\n\ntlist, coeffs = sarimner.load_circuit(circuit)\n\nsarimner.plot_pulses(show_axis=True);\n</code></pre> <p></p>"},{"location":"user_guide/quantum_gates/#cz-gate","title":"CZ-gate","text":"<p>The CZ-gate between two qubits are performed using a time-dependent coupling term of the form</p> \\[ \\frac{H_\\mathrm{coupling}(t)}{\\hbar} = g(t)(\\ket{20}\\bra{11}+\\ket{11}\\bra{20}). \\] <p>where the time-dependent coupling term \\(g(t)\\) is given by a step-function with amplitude \\(g\\) and sinusodial rise-and-fall time. The gate time is in this case given by</p> \\[ t_\\mathrm{gate} = \\frac{1}{\\sqrt{2}2g}. \\] <ol> <li> <p>F. Motzoi, J. M. Gambetta, P. Rebentrost, and F. K. Wilhelm. Simple pulses for elimination of leakage in weakly nonlinear qubits. Phys. Rev. Lett., 103:110501, Sep 2009. doi:10.1103/PhysRevLett.103.110501.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/transmons/","title":"Model","text":""},{"location":"user_guide/transmons/#transmons","title":"Transmons","text":"<p>Quantum processors operate based on the manipulation of qubits. To simulate how quantum circuits behave on such devices, we model their Hamiltonian. The Hamiltonian for a transmon qubit, is given by:</p> \\[ \\frac{H}{\\hbar} = \\sum_{i=1}^N(\\omega_{q_i} a_i^\\dagger a_i + \\frac{\\alpha_i}{2} a_i^{\\dagger 2} a_i^2), \\] <p>where \\(N\\) is the number of qubits, \\(\\omega_{q_i}\\) is the qubit frequency and \\(\\alpha_i\\) is the anhamronicity for the \\(i\\):th qubit. We often work in a rotating frame to simplify calculations. This involves applying a transformation \\(U(t) = e^{i\\omega_r t a^\\dagger a}\\), where \\(\\omega_r\\) is the rotating frame frequency. In this frame, the Hamiltonian becomes:</p> \\[ \\frac{H^R}{\\hbar} = \\sum_{i=1}^N(\\Delta_i a_i^\\dagger a_i + \\frac{\\alpha_i}{2} a_i^{\\dagger 2} a^2_i). \\] <p>Here \\(\\Delta_i = \\omega_{q_i} - \\omega_{r_i}\\) represents the detuning of the i-th qubit, which is the difference between its intrinsic frequency and the rotating frame frequency.</p>"},{"location":"user_guide/transmons/#example-initializing-a-model-with-hardware-parameters","title":"Example: Initializing a Model with Hardware Parameters","text":"<p>The <code>SarimnerModel</code> allows us to create a model with specific hardware parameters. Here's an example of how to initialize such a model:</p> <pre><code>from chalmers_qubit.devices.sarimner import SarimnerModel\n# Qubit frequencies are given in (GHz)\ntransmon_dict = {\n    0: {\"frequency\": 5.0, \"anharmonicity\": -0.30},\n}\n\n# Load the physical parameters onto the model\nmodel = SarimnerModel(transmon_dict=transmon_dict)\n</code></pre> <p>This code defines qubit frequencies and anharmonicities for a single qubit system (N=1) and creates a <code>SarimnerModel</code> object to represent the physical system.</p> <p>Note: All simulations are performed in the rotating frame of the individual qubits.</p>"}]}